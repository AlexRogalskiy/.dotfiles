SCRIPT  /Users/john/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim
Sourced 1 time
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2021 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003 scriptencoding utf-8
                            
    1              0.000004 function! airline#extensions#tabline#formatters#default#format(bufnr, buffers)
                              let fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
                              let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
                              let _ = ''
                            
                              let name = bufname(a:bufnr)
                              if empty(name)
                                let _ .= '[No Name]'
                              elseif name =~ 'term://'
                                " Neovim Terminal
                                let _ = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
                              else
                                if get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
                                  let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
                                endif
                                if a:bufnr != bufnr('%') && fnametruncate && strlen(_) > fnametruncate
                                  let _ = airline#util#strcharpart(_, 0, fnametruncate)
                                endif
                              endif
                            
                              return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)
                            endfunction
                            
    1              0.000002 function! airline#extensions#tabline#formatters#default#wrap_name(bufnr, buffer_name)
                              let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
                              let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
                              let buf_modified_symbol = g:airline_symbols.modified
                            
                              let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
                              let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
                              if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= buf_modified_symbol
                              endif
                              return _
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/ftplugin/vim.vim
Sourced 1 time
Total time:   0.023322
 Self time:   0.023322

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2018 Aug 07
                            
                            " Only do this when not done yet for this buffer
    1              0.000010 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
                            " Don't load another plugin for this buffer
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000008 set cpo-=C
                            
    1              0.000003 if !exists('*VimFtpluginUndo')
    1              0.000001   func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< keywordprg<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                 endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
    1              0.000001 endif
                            
    1              0.000002 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000008 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000021 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    1              0.000003 setlocal keywordprg=:help
                            
                            " Set 'comments' to format dashed lists in comments
    1              0.000005 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    1              0.000002 if &tw == 0
    1              0.000007   setlocal tw=78
    1              0.000004 endif
                            
                            " Comments start with a double quote
    1              0.000002 setlocal commentstring=\"%s
                            
                            " Prefer Vim help instead of manpages.
    1              0.000002 setlocal keywordprg=:help
                            
    1              0.000003 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    1              0.000002   let b:did_add_maps = 1
                            
                              " Move around functions.
    1              0.000018   nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    1              0.000008   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    1              0.000006   nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    1              0.000007   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    1              0.000029   nnoremap <silent><buffer> [] m':call search('^\s*endf\%[unction]\>', "bW")<CR>
    1              0.000007   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf\%[unction]\>', "bW")<CR>
    1              0.000005   nnoremap <silent><buffer> ][ m':call search('^\s*endf\%[unction]\>', "W")<CR>
    1              0.000019   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf\%[unction]\>', "W")<CR>
                            
                              " Move around comments
    1              0.000005   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000006   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000006   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000006   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000001 endif
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000002 if exists("loaded_matchit")
    1              0.000002   let b:match_ignorecase = 0
    1              0.000008   let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
    1              0.000002   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    1              0.000001 endif
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/indent/vim.vim
Sourced 1 time
Total time:   0.004145
 Self time:   0.004145

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jun 27
                            
                            " Only load this indent file when no other was loaded.
    1              0.000019 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000002 let b:did_indent = 1
                            
    1              0.000006 setlocal indentexpr=GetVimIndent()
    1              0.000004 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\,0=\"\\\ 
                            
    1              0.000002 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetVimIndent")
                              finish
    1              0.000001 endif
    1              0.000005 let s:keepcpo= &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000001 function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
    1              0.000001 let s:lineContPat = '^\s*\(\\\|"\\ \)'
                            
    1              0.000001 function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ s:lineContPat
                                while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                              let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                              if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                if prev_text !~ '^\s*au\%[tocmd]'
                                  let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
    1              0.000011 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/syntax/vim.vim
Sourced 1 time
Total time:   0.013152
 Self time:   0.013152

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000019 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
    1              0.000007 let s:keepcpo= &cpo
    1              0.000006 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000019 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000004 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000011 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    1              0.000008 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000026 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000032 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000006 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000028 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    1              0.000131 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    1              0.000003 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    1              0.000016 syn match   vimTermOption contained	"t_%1"
    1              0.000002 syn match   vimTermOption contained	"t_#2"
    1              0.000002 syn match   vimTermOption contained	"t_#4"
    1              0.000002 syn match   vimTermOption contained	"t_@7"
    1              0.000002 syn match   vimTermOption contained	"t_*7"
    1              0.000002 syn match   vimTermOption contained	"t_&8"
    1              0.000002 syn match   vimTermOption contained	"t_%i"
    1              0.000002 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    1              0.000007 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    1              0.000001 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000044 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    1              0.000024 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu 
    1              0.000216 syn match vimHLGroup contained	"Conceal"
    1              0.000011 syn keyword vimOnlyHLGroup contained	VisualNOS
    1              0.000024 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC QuickFixLine
                            "}}}2
    1              0.000001 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands
    1              0.000006 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[aflmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    1              0.000001 else
    1              0.000008  com! -nargs=*	VimFolda	<args>
    1              0.000004  com! -nargs=*	VimFoldf	<args>
    1              0.000004  com! -nargs=*	VimFoldl	<args>
    1              0.000003  com! -nargs=*	VimFoldm	<args>
    1              0.000003  com! -nargs=*	VimFoldp	<args>
    1              0.000003  com! -nargs=*	VimFoldP	<args>
    1              0.000003  com! -nargs=*	VimFoldr	<args>
    1              0.000003  com! -nargs=*	VimFoldt	<args>
    1              0.000001 endif
                            
                            " commands not picked up by the generator (due to non-standard format)
    1              0.000002 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    1              0.000002 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    1              0.000001 endif
    1              0.000002 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    1              0.000000 endif
    1              0.000002 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    1              0.000000 endif
                            
                            " Variable options {{{2
    1              0.000001 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    1              0.000000 else
    1              0.000002  let s:vimsyn_maxlines= 60
    1              0.000001 endif
                            
                            " Numbers {{{2
                            " =======
    1              0.000055 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    1              0.000007 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    1              0.000006 syn match vimNumber	"\<0[xX]\x\+"		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    1              0.000007 syn match vimNumber	"\%(^\|\A\)\zs#\x\{6}"             	       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    1              0.000099 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimEcho,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    1              0.000008 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    1              0.000008 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    1              0.000004 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000003 syn match vimVar	      	"\s\zs&\a\+\>"
    1              0.000007 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000002 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    1              0.000014 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$""
    1              0.000007 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$""
    1              0.000005 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$""
    1              0.000006 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=starti\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    1              0.000015 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    1              0.000002 syn keyword vimBehaveModel contained	mswin	xterm
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000003  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000001 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000020 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000002  syn match   vimFTError  contained	"\I\i*"
    1              0.000001 endif
    1              0.000033 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000003 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000099 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimNotFunc,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    1              0.000003 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
    1              0.000001 else
    1              0.000013  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    1              0.000001 endif
    1              0.000004 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000007  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000001 endif
    1              0.000003 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    1              0.000019 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    1              0.000017 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000008 syn match	vimOper	"\(\<is\|\<isnot\)[?#]\{0,2}\>"			skipwhite nextgroup=vimString,vimSpecFile
    1              0.000005 syn match	vimOper	"||\|&&\|[-+.!]"				skipwhite nextgroup=vimString,vimSpecFile
    1              0.000010 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    1              0.000009 syn region	vimOperParen	matchgroup=vimSep		start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000006  syn match	vimOperError	")"
    1              0.000001 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000019 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    1              0.000068 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSearch,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    1              0.000019 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    1              0.000003 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    1              0.000001 else
    1              0.000007  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    1              0.000001 endif
    1              0.000003 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    1              0.000005 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    1              0.000003 syn keyword	vimFuncKey   contained	fu[nction]
    1              0.000006 syn match	vimFuncBlank contained	"\s\+"
                            
    1              0.000006 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000032 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000006 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000005 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000004 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000004 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000017 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000003 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000048 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    1              0.000002 syn keyword	vimUserCommand	contained	com[mand]
    1              0.000015 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    1              0.000003 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    1              0.000009 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    1              0.000014 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    1              0.000006 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000006 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000004 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    1              0.000004 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    1              0.000004 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    1              0.000004 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000003  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000001 endif
    1              0.000001 syn case ignore
    1              0.000008 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    1              0.000010 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    1              0.000008 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    1              0.000007 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    1              0.000001 syn case match
    1              0.000002 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000009 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000005 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000004 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    1              0.000005 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000002 syn match	vimEnvvar	"\$\I\i*"
    1              0.000002 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000007 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000006 syn match	vimPatSepErr	contained	"\\)"
    1              0.000006 syn match	vimPatSep	contained	"\\|"
    1              0.000031 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    1              0.000040 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000022 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000007 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000013 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    1              0.000004 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    1              0.000006 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    1              0.000008 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    1              0.000012 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    1              0.000011 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    1              0.000003 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000014 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000012 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000006 syn cluster	vimSubstList	add=vimCollection
    1              0.000013 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
    1              0.000006 syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    1              0.000004 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    1              0.000006 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    1              0.000008 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000022 syn match	vimSubst2       contained	"s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000031 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000048 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000011 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000007 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    1              0.000010 syn match	vimCollClass    contained transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    1              0.000002 syn match	vimSubstSubstr  contained	"\\z\=\d"
    1              0.000002 syn match	vimSubstTwoBS   contained	"\\\\"
    1              0.000010 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000003 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    1              0.000003 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000013 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000006 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000006 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000006 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000008 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000004 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst2
    1              0.000006 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    1              0.000010 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    1              0.000006 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000003 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000005 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000002 syn match	vimRegister	'@"'
    1              0.000009 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    1              0.000004 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000004 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000006 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000005 syn match	vimFilter contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
                            
                            " Complex repeats (:h complex-repeat) {{{2
    1              0.000003 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000005 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000028 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" end="|" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod
    1              0.000021 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1	contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    1              0.000007 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+		contains=vimCtrlChar
    1              0.000006 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    1              0.000003 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    1              0.000006 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    1              0.000020 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    1              0.000021 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000007 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000002 syn match	vimAutoCmdSfxList	contained	"\S*"
    1              0.000008 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    1              0.000012 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    1              0.000022 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    1              0.000013 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000001 syn case ignore
    1              0.000002 syn keyword	vimEchoHLNone	none
    1              0.000001 syn case match
                            
                            " Maps {{{2
                            " ====
    1              0.000005 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000024 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000011 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000003 syn keyword	vimMap		mapc[lear] smapc[lear]
    1              0.000012 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000008 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000014 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    1              0.000004 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000020 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000013 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    1              0.000008 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    1              0.000001 syn case ignore
    1              0.000006 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    1              0.000001 syn case match
                            
                            " Menus {{{2
                            " =====
    1              0.000020 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    1              0.000020 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    1              0.000013 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    1              0.000004 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    1              0.000010 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    1              0.000013 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    1              0.000007 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    1              0.000006 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    1              0.000016 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000001 syn case ignore
    1              0.000048 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cmd\|cr\|lf\|linefeed\|return\|enter\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|mouse\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    1              0.000031 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    1              0.000041 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"			contains=vimBracket
    1              0.000024 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    1              0.000015 syn match	vimNotation	'\%#=1\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    1              0.000013 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    1              0.000005 syn match	vimBracket contained	"[\\<>]"
    1              0.000001 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000018 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    1              0.000014 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000008  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
    1              0.000008  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000007  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000009  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000001 endif
                            
    1              0.000015 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"	skipwhite nextgroup=vimOper,vimOperParen,vimVar,vimFunc,vimNotation
                            
                            " Norm {{{2
                            " ====
    1              0.000007 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    1              0.000002 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    1              0.000012 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    1              0.000008 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    1              0.000002 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000006  syn match	vimSynError	contained	"\i\+"
    1              0.000003  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000001 endif
    1              0.000008 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    1              0.000008 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    1              0.000009 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    1              0.000013 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    1              0.000010 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    1              0.000006 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000011 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000002  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000001 endif
    1              0.000002 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000003 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000007 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000119 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000004 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    1              0.000005 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    1              0.000005 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    1              0.000007 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000007 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000002 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000002 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    1              0.000003 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    1              0.000009 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000032 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000011 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000007 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    1              0.000003 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    1              0.000023 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    1              0.000007 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000012 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000008 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    1              0.000003 if has("conceal")
    1              0.000011  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    1              0.000002  syn match	vimSynMtchCchar	contained	"\S"
    1              0.000001 endif
    1              0.000007 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    1              0.000003 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000022 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000017 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000006 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000007 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    1              0.000009 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000006 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    1              0.000010 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000014 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000006 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000005 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000002 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000003 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000011 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000002 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000003 syn match	vimMtchComment	contained	'"[^"]\+$'
    1              0.000003 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000034 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000002  syn match	vimSyncError	contained	"\i\+"
    1              0.000001 endif
    1              0.000002 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000007 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000002 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000005 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000002 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000007 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000007 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000008 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000008 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000001 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    1              0.000011 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    1              0.000017 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000006  syn match	vimHiCtermError	contained	"\D\i*"
    1              0.000001 endif
    1              0.000013 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000003 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000006 syn match	vimHiGroup	contained	"\i\+"
    1              0.000001 syn case ignore
    1              0.000011 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl
    1              0.000007 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000001 syn case match
    1              0.000007 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000004 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000001 syn case ignore
    1              0.000063 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    1              0.000005 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000001 syn case match
    1              0.000008 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000008 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000007 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000051 syn cluster	vimHiCluster contains=vimGroup,vimHiBlend,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    1              0.000008 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000002  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000001 endif
    1              0.000006 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000010 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000004 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000010 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000003 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000003 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000007 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000010 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000003 syn match	vimHiBlend	contained	"\cblend="he=e-1		nextgroup=vimHiNmbr
    1              0.000002 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000003 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    1              0.000011 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=@vimHiCluster
    1              0.000003 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    1              0.000003 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000012 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000016 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000005 syn match	vimContinue	"^\s*\\"
    1              0.000016 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000003 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000008 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000003 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000015 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    1              0.000012 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    1              0.000002 if !exists("g:vimsyn_embed")
    1              0.000002  let g:vimsyn_embed= 0
    1              0.000001 endif
                            
                            " [-- lua --] {{{3
    1              0.000036 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000540 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000008 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimLuaRegion
                             exe "syn include @vimLuaScript ".s:luapath
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+	contains=@vimLuaScript
                             syn cluster vimFuncBodyList	add=vimLuaRegion
    1              0.000001 else
    1              0.000015  syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000006  syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000021 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000687 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000005 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
    1              0.000001 else
    1              0.000008  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000019 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000019 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000524 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000005 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
                             syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
    1              0.000001 else
    1              0.000005  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000019 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000368 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000005 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+			contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+			contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
    1              0.000001 else
    1              0.000007  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000008 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
    1              0.000001 else
    1              0.000001  let s:trytcl= 1
    1              0.000000 endif
    1              0.000001 if s:trytcl
    1              0.000018  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000048  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    1              0.000001  endif
    1              0.000004  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    1              0.000001  else
    1              0.000006   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000001  endif
    1              0.000001  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000017 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000047 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000004 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    1              0.000001 else
    1              0.000019  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    1              0.000013 endif
    1              0.000001 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000002 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    1              0.000000 endif
    1              0.000004 exe "syn sync maxlines=".s:vimsyn_maxlines
    1              0.000003 syn sync linecont	"^\s\+\\"
    1              0.000012 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000017 if !exists("skip_vim_syntax_inits")
    1              0.000002  if !exists("g:vimsyn_noerror")
    1              0.000008   hi def link vimBehaveError	vimError
    1              0.000015   hi def link vimCollClassErr	vimError
    1              0.000002   hi def link vimErrSetting	vimError
    1              0.000005   hi def link vimEmbedError	Normal
    1              0.000002   hi def link vimFTError	vimError
    1              0.000002   hi def link vimFunctionError	vimError
    1              0.000001   hi def link vimFunc         	vimError
    1              0.000001   hi def link vimHiAttribList	vimError
    1              0.000001   hi def link vimHiCtermError	vimError
    1              0.000001   hi def link vimHiKeyError	vimError
    1              0.000005   hi def link vimKeyCodeError	vimError
    1              0.000001   hi def link vimMapModErr	vimError
    1              0.000001   hi def link vimSubstFlagErr	vimError
    1              0.000001   hi def link vimSynCaseError	vimError
    1              0.000020   hi def link vimBufnrWarn	vimWarn
    1              0.000001  endif
                            
    1              0.000002  hi def link vimAbb	vimCommand
    1              0.000002  hi def link vimAddress	vimMark
    1              0.000001  hi def link vimAugroupError	vimError
    1              0.000015  hi def link vimAugroupKey	vimCommand
    1              0.000005  hi def link vimAuHighlight	vimHighlight
    1              0.000006  hi def link vimAutoCmdOpt	vimOption
    1              0.000007  hi def link vimAutoCmd	vimCommand
    1              0.000005  hi def link vimAutoEvent	Type
    1              0.000006  hi def link vimAutoSet	vimCommand
    1              0.000002  hi def link vimBehaveModel	vimBehave
    1              0.000002  hi def link vimBehave	vimCommand
    1              0.000007  hi def link vimBracket	Delimiter
    1              0.000005  hi def link vimCmplxRepeat	SpecialChar
    1              0.000005  hi def link vimCommand	Statement
    1              0.000005  hi def link vimComment	Comment
    1              0.000002  hi def link vimCommentString	vimString
    1              0.000021  hi def link vimCommentTitle	PreProc
    1              0.000006  hi def link vimCondHL	vimCommand
    1              0.000020  hi def link vimContinue	Special
    1              0.000005  hi def link vimCtrlChar	SpecialChar
    1              0.000002  hi def link vimEchoHLNone	vimGroup
    1              0.000002  hi def link vimEchoHL	vimCommand
    1              0.000005  hi def link vimElseIfErr	Error
    1              0.000005  hi def link vimElseif	vimCondHL
    1              0.000005  hi def link vimEnvvar	PreProc
    1              0.000004  hi def link vimError	Error
    1              0.000002  hi def link vimFBVar	vimVar
    1              0.000001  hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000008  hi def link vimFold	Folded
    1              0.000002  hi def link vimFTCmd	vimCommand
    1              0.000002  hi def link vimFTOption	vimSynType
    1              0.000002  hi def link vimFuncKey	vimCommand
    1              0.000005  hi def link vimFuncName	Function
    1              0.000007  hi def link vimFuncSID	Special
    1              0.000005  hi def link vimFuncVar	Identifier
    1              0.000005  hi def link vimGroupAdd	vimSynOption
    1              0.000002  hi def link vimGroupName	vimGroup
    1              0.000001  hi def link vimGroupRem	vimSynOption
    1              0.000004  hi def link vimGroupSpecial	Special
    1              0.000005  hi def link vimGroup	Type
    1              0.000004  hi def link vimHiAttrib	PreProc
    1              0.000001  hi def link vimHiBlend	vimHiTerm
    1              0.000002  hi def link vimHiClear	vimHighlight
    1              0.000001  hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000001  hi def link vimHiCTerm	vimHiTerm
    1              0.000002  hi def link vimHighlight	vimCommand
    1              0.000001  hi def link vimHiGroup	vimGroupName
    1              0.000001  hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000001  hi def link vimHiGuiFont	vimHiTerm
    1              0.000002  hi def link vimHiGuiRgb	vimNumber
    1              0.000001  hi def link vimHiGui	vimHiTerm
    1              0.000004  hi def link vimHiNmbr	Number
    1              0.000001  hi def link vimHiStartStop	vimHiTerm
    1              0.000004  hi def link vimHiTerm	Type
    1              0.000002  hi def link vimHLGroup	vimGroup
    1              0.000008  hi def link vimHLMod	PreProc
    1              0.000002  hi def link vimInsert	vimString
    1              0.000005  hi def link vimIskSep	Delimiter
    1              0.000006  hi def link vimKeyCode	vimSpecFile
    1              0.000008  hi def link vimKeyword	Statement
    1              0.000002  hi def link vimLet	vimCommand
    1              0.000002  hi def link vimLineComment	vimComment
    1              0.000002  hi def link vimMapBang	vimCommand
    1              0.000006  hi def link vimMapModKey	vimFuncSID
    1              0.000004  hi def link vimMapMod	vimBracket
    1              0.000002  hi def link vimMap	vimCommand
    1              0.000005  hi def link vimMark	Number
    1              0.000002  hi def link vimMarkNumber	vimNumber
    1              0.000001  hi def link vimMenuMod	vimMapMod
    1              0.000001  hi def link vimMenuNameMore	vimMenuName
    1              0.000004  hi def link vimMenuName	PreProc
    1              0.000002  hi def link vimMtchComment	vimComment
    1              0.000002  hi def link vimNorm	vimCommand
    1              0.000007  hi def link vimNotation	Special
    1              0.000002  hi def link vimNotFunc	vimCommand
    1              0.000002  hi def link vimNotPatSep	vimString
    1              0.000005  hi def link vimNumber	Number
    1              0.000005  hi def link vimOperError	Error
    1              0.000005  hi def link vimOper	Operator
    1              0.000005  hi def link vimOption	PreProc
    1              0.000005  hi def link vimParenSep	Delimiter
    1              0.000001  hi def link vimPatSepErr	vimError
    1              0.000002  hi def link vimPatSepR	vimPatSep
    1              0.000005  hi def link vimPatSep	SpecialChar
    1              0.000002  hi def link vimPatSepZone	vimString
    1              0.000002  hi def link vimPatSepZ	vimPatSep
    1              0.000005  hi def link vimPattern	Type
    1              0.000002  hi def link vimPlainMark	vimMark
    1              0.000002  hi def link vimPlainRegister	vimRegister
    1              0.000005  hi def link vimRegister	SpecialChar
    1              0.000008  hi def link vimScriptDelim	Comment
    1              0.000004  hi def link vimSearchDelim	Statement
    1              0.000002  hi def link vimSearch	vimString
    1              0.000007  hi def link vimSep	Delimiter
    1              0.000002  hi def link vimSetMod	vimOption
    1              0.000006  hi def link vimSetSep	Statement
    1              0.000002  hi def link vimSetString	vimString
    1              0.000005  hi def link vimSpecFile	Identifier
    1              0.000002  hi def link vimSpecFileMod	vimSpecFile
    1              0.000008  hi def link vimSpecial	Type
    1              0.000008  hi def link vimStatement	Statement
    1              0.000002  hi def link vimStringCont	vimString
    1              0.000005  hi def link vimString	String
    1              0.000002  hi def link vimStringEnd	vimString
    1              0.000002  hi def link vimSubst1	vimSubst
    1              0.000005  hi def link vimSubstDelim	Delimiter
    1              0.000005  hi def link vimSubstFlags	Special
    1              0.000005  hi def link vimSubstSubstr	SpecialChar
    1              0.000002  hi def link vimSubstTwoBS	vimString
    1              0.000002  hi def link vimSubst	vimCommand
    1              0.000005  hi def link vimSynCaseError	Error
    1              0.000005  hi def link vimSynCase	Type
    1              0.000005  hi def link vimSyncC	Type
    1              0.000005  hi def link vimSyncError	Error
    1              0.000002  hi def link vimSyncGroupName	vimGroupName
    1              0.000001  hi def link vimSyncGroup	vimGroupName
    1              0.000004  hi def link vimSyncKey	Type
    1              0.000005  hi def link vimSyncNone	Type
    1              0.000001  hi def link vimSynContains	vimSynOption
    1              0.000005  hi def link vimSynError	Error
    1              0.000002  hi def link vimSynKeyContainedin	vimSynContains
    1              0.000001  hi def link vimSynKeyOpt	vimSynOption
    1              0.000001  hi def link vimSynMtchGrp	vimSynOption
    1              0.000001  hi def link vimSynMtchOpt	vimSynOption
    1              0.000003  hi def link vimSynNextgroup	vimSynOption
    1              0.000001  hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000004  hi def link vimSynOption	Special
    1              0.000002  hi def link vimSynPatRange	vimString
    1              0.000001  hi def link vimSynRegOpt	vimSynOption
    1              0.000002  hi def link vimSynRegPat	vimString
    1              0.000005  hi def link vimSynReg	Type
    1              0.000002  hi def link vimSyntax	vimCommand
    1              0.000001  hi def link vimSynType	vimSpecial
    1              0.000005  hi def link vimTodo	Todo
    1              0.000002  hi def link vimUnmap	vimMap
    1              0.000005  hi def link vimUserAttrbCmpltFunc	Special
    1              0.000002  hi def link vimUserAttrbCmplt	vimSpecial
    1              0.000002  hi def link vimUserAttrbKey	vimOption
    1              0.000001  hi def link vimUserAttrb	vimSpecial
    1              0.000005  hi def link vimUserAttrbError	Error
    1              0.000005  hi def link vimUserCmdError	Error
    1              0.000002  hi def link vimUserCommand	vimCommand
    1              0.000005  hi def link vimUserFunc	Normal
    1              0.000005  hi def link vimVar	Identifier
    1              0.000005  hi def link vimWarn	WarningMsg
                            
    1              0.000002  hi def link nvimAutoEvent	vimAutoEvent
    1              0.000002  hi def link nvimHLGroup	vimHLGroup
    1              0.000002  hi def link nvimMap	vimMap
    1              0.000002  hi def link nvimUnmap	vimUnmap
    1              0.000001 endif
                            
                            " Current Syntax Variable: {{{2
    1              0.000002 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000002 delc VimFolda
    1              0.000001 delc VimFoldf
    1              0.000001 delc VimFoldl
    1              0.000001 delc VimFoldm
    1              0.000001 delc VimFoldp
    1              0.000001 delc VimFoldP
    1              0.000001 delc VimFoldr
    1              0.000001 delc VimFoldt
    1              0.000009 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/syntax/vim/generated.vim
Sourced 3 times
Total time:   0.014597
 Self time:   0.014597

count  total (s)   self (s)
    3              0.001824 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bal[t] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] caf[ter] cal[l] cat[ch] cb[uffer] cbe[fore] cbel[ow] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev]
    3              0.000174 syn keyword vimCommand contained  cnorem[enu] co[py] col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cons[t] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] ha[rdcopy]
    3              0.000159 syn keyword vimCommand contained  hi[ghlight] hid[e] his[tory] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] laf[ter] lat[er] lb[uffer] lbe[fore] lbel[ow] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd]
    3              0.000423 syn keyword vimCommand contained  lw[indow] ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] new nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] perlf[ile] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[file] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] pyx pyxd[o] pyt[honx] pyx[file] q[uit] quita[ll] qa[ll] r[ead]
    3              0.000165 syn keyword vimCommand contained  rec[over] red[o] redi[r] redr[aw] redraws[tatus] redrawt[abline] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend]
    3              0.000162 syn keyword vimCommand contained  sv[iew] sw[apname] sy[ntax] synti[me] sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[enu] tma[p] tmapc[lear] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmenu] tunma[p] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[hada] wu[ndo] wv[iminfo] x[it]
    3              0.000025 syn keyword vimCommand contained  xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    3              0.000062 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh buflisted bl invbuflisted nobuflisted invbl nobl
    3              0.000073 syn keyword vimOption contained  buftype bt casemap cmp cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot completeslash csl confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
    3              0.000139 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol
    3              0.000073 syn keyword vimOption contained  foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc
    3              0.000068 syn keyword vimOption contained  imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs jumpoptions jop keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl
    3              0.000063 syn keyword vimOption contained  magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmempattern mmp menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelineexpr mle invmodelineexpr nomodelineexpr invmle nomle modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste pastetoggle pt
    3              0.000116 syn keyword vimOption contained  patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumblend pb pumheight ph pumwidth pw pyxversion pyx quoteescape qe readonly ro invreadonly noreadonly invro noro redrawdebug rdb redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk scrollbind scb invscrollbind noscrollbind invscb noscb
    3              0.000069 syn keyword vimOption contained  scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shadafile sdf shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi
    3              0.000068 syn keyword vimOption contained  smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps spelloptions spo splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tagfunc tfu tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc
    3              0.000065 syn keyword vimOption contained  termpastefilter tpf terse invterse noterse textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi viminfofile vif virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak winblend winbl winhighlight winhl window wi
    3              0.000033 syn keyword vimOption contained  winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    3              0.000003 syn case ignore
                            
    3              0.000108 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre ChanInfo ChanOpen CmdUndefined CmdWinEnter CmdWinLeave CmdlineChanged CmdlineEnter CmdlineLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedI DiffUpdated EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave InsertLeavePre
    3              0.000043 syn keyword vimAutoEvent contained  MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermEnter TermLeave TermResponse TextChanged TextChangedI TextChangedP TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinEnter WinLeave WinNew BufRead BufWrite FileEncoding BufCreate
                            
    3              0.000015 syn keyword nvimAutoEvent contained  UIEnter TabClosed TabNew TabNewEntered DirChanged BufModifiedSet WinClosed TermOpen Signal UILeave WinScrolled TermClose
                            
    3              0.000002 syn case match
                            
    3              0.000060 syn keyword vimFuncName contained  winwidth tr confirm search undofile readdir readfile reg_executing reg_recording reltime reltimefloat reltimestr resolve round rpcnotify rpcrequest rpcstart rpcstop rubyeval screenattr screenchar screencol screenpos screenrow searchdecl searchpair searchpairpos searchpos serverlist serverstart serverstop setbufline setbufvar setcharsearch setcmdpos setenv setfperm setline setloclist setmatches setpos setqflist setreg settabvar settabwinvar settagstack setwinvar sha256 shellescape sign_define sign_getdefined sign_getplaced buflisted sign_place sign_undefine sign_unplace simplify sockconnect soundfold stdioopen spellbadword stdpath str2float str2list str2nr strcharpart strchars strdisplaywidth strftime strgetchar stridx strlen strpart strridx strtrans strwidth submatch swapinfo synID synIDattr synIDtrans synconcealed
    3              0.000065 syn keyword vimFuncName contained  synstack system systemlist tabpagebuflist tabpagenr tabpagewinnr tagfiles taglist tempname termopen test_garbagecollect_now test_write_list_log timer_info timer_pause function timer_stop timer_stopall tolower toupper trim trunc or repeat uniq values virtcol visualmode wait wildmenumode win_findbuf win_getid win_gettype win_gotoid win_id2tabwin win_id2win win_screenpos string wincol windowsversion winlayout winline winnr winrestcmd winrestview type wordcount writefile xor nvim_buf_attach nvim__stats add nvim_list_uis nvim_tabpage_list_wins nvim_get_proc_children nvim_tabpage_get_var nvim_select_popupmenu_item insert remove sort input execute rename getenv len reverse match abs floor ceil sqrt log10 exp sin cos tan asin acos atan sinh cosh tanh log atan2 pow fmod min max shiftwidth foldlevel foldtext substitute
    3              0.000047 syn keyword vimFuncName contained  nvim_set_current_buf nvim_list_wins nvim_get_current_win nvim_set_current_win nvim_create_buf nvim_open_win nvim_list_tabpages nvim_get_current_tabpage nvim_set_current_tabpage nvim_create_namespace append nvim_get_namespaces nvim_paste nvim_put nvim_get_color_by_name nvim_get_color_map nvim_get_context nvim_load_context nvim_get_mode nvim_get_keymap nvim_set_keymap nvim_del_keymap split nvim_get_commands nvim_get_chan_info nvim_list_chans nvim_parse_expression nvim__id nvim__id_array nvim__id_dictionary expand swapname list2str luaeval and matchadd matchdelete matchstr browse msgpackdump nr2char printf nvim_buf_delete nvim_buf_get_mark nvim_command nvim_tabpage_get_number nvim_buf_get_extmarks file_readable nvim_del_var index getreg getqflist nvim_echo timer_start browsedir join getfsize getfperm nvim_win_is_valid
    3              0.000050 syn keyword vimFuncName contained  nvim__inspect_cell getcwd nvim__screenshot call nvim_win_get_buf nvim_win_get_tabpage nvim_win_set_buf getcompletion nvim_win_get_cursor prompt_setprompt nvim_win_set_cursor getcmdtype nvim_win_get_height getpid nvim_win_set_height getcmdline nvim_win_get_width pyxeval nvim_win_set_width getbufvar nvim_win_get_var getbufline eval getbufinfo get foreground foldtextresult nvim_win_get_option fnameescape prevnonblank filter mode delete api_info prompt_setinterrupt appendbufline argc argidx arglistid argv map assert_beeps assert_equal assert_fails assert_false assert_notequal assert_notmatch assert_report assert_true bufadd bufexists buffer_exists pumvisible buffer_name cindent buffer_number copy bufload bufloaded bufname bufnr bufwinid bufwinnr byte2line byteidx byteidxcomp changenr chanclose chansend char2nr
    3              0.000057 syn keyword vimFuncName contained  charidx clearmatches col complete_add complete_check complete_info count cscope_connection ctxget ctxpop ctxpush ctxset ctxsize cursor debugbreak deepcopy deletebufline dictwatcheradd dictwatcherdel did_filetype diff_filler diff_hlID empty environ escape eventhandler executable exepath exists expandcmd feedkeys foldclosed foldclosedend filereadable filewritable finddir findfile flatten float2nr getchangelist getchar nvim_tabpage_set_var getcharsearch nvim_buf_get_lines getcmdpos nvim_tabpage_get_win getcmdwintype nvim_buf_set_lines getcurpos nvim_tabpage_is_valid getfontname assert_equalfile nvim_buf_set_text getftime assert_exception assert_inrange assert_match fnamemodify nvim_buf_get_offset getmatches nvim_buf_get_var getpos funcref gettabvar nvim_buf_get_changedtick gettabinfo nvim_buf_get_keymap inputdialog
    3              0.000050 syn keyword vimFuncName contained  gettabwinvar nvim_buf_set_keymap inputsave gettagstack nvim_exec invert getwininfo nvim_buf_del_keymap islocked nvim_get_hl_by_name id nvim_buf_set_var jobclose nvim_get_hl_by_id highlightID nvim_buf_del_var jobpid nvim_get_hl_id_by_name jobsend nvim__get_hl_defs histadd nvim_set_hl jobstop nvim_buf_set_name hlexists nvim_set_hl_ns keys nvim_feedkeys libcall nvim_buf_is_valid line nvim_input lispindent nvim_input_mouse localtime nvim_buf_get_extmark_by_id maparg getwinpos getwinposx nvim_replace_termcodes matcharg getwinposy nvim_buf_set_extmark matchlist nvim_buf_del_extmark matchstrpos nvim_buf_add_highlight mkdir nvim_eval msgpackparse getwinvar glob nvim_notify nvim_win_set_var glob2regpat globpath nvim_call_function nvim_win_del_var has nvim_call_dict_function py3eval pyeval nvim_strwidth nvim_win_get_position
    3              0.000042 syn keyword vimFuncName contained  haslocaldir nvim_list_runtime_paths nvim_set_option nvim_get_runtime_file perleval hasmapto nvim__get_lib_dir nvim_win_set_config nvim_set_current_dir nvim_win_get_config highlight_exists nvim_win_close nvim_get_current_line nvim_set_current_line nvim_buf_clear_highlight nvim_del_current_line histdel histget nvim_buf_get_number nvim_set_var iconv json_decode nvim_command_output nvim_get_vvar nvim__buf_stats nvim_set_vvar nvim_get_option_info nvim_buf_set_virtual_text spellsuggest nvim_buf_line_count nvim_get_all_options_info nvim_buf_clear_namespace nvim_get_option garbagecollect hlID nvim_tabpage_del_var nvim_get_var nvim_out_write nvim_win_get_number nvim_err_write range nvim_err_writeln nvim_win_set_option nvim_list_bufs pum_getpos nvim_get_current_buf prompt_setcallback nvim_buf_is_loaded pathshorten nvim_buf_get_name
    3              0.000034 syn keyword vimFuncName contained  nextnonblank nvim_buf_set_option menu_get nvim_buf_get_option matchend nvim_buf_get_commands matchaddpos histnr mapcheck json_encode indent line2byte libcallnr last_buffer_nr hostname jobwait jobstart jobresize items isnan isinf isdirectory interrupt inputsecret inputrestore inputlist getregtype winheight getmarklist getloclist getline getjumplist getftype extend getcharmod sign_jump complete undotree nvim_get_proc nvim__id_float winsaveview winbufnr has_key

SCRIPT  /Users/john/.config/nvim/autoload/plugged/vim-signify/autoload/sy.vim
Sourced 1 time
Total time:   0.000624
 Self time:   0.000624

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000003 scriptencoding utf-8
                            
                            " #start {{{1
                            " Optional argument: {'bufnr': X }
    1              0.000003 function! sy#start(...) abort
                              if g:signify_locked
                                call sy#verbose('Locked.')
                                return
                              endif
                            
                              let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
                              let sy = getbufvar(bufnr, 'sy')
                            
                              if empty(sy)
                                let path = s:get_path(bufnr)
                                if s:skip(bufnr, path)
                                  call sy#verbose('Skip file: '. path)
                                  return
                                endif
                                call sy#verbose('Register new file: '. path)
                                let new_sy = {
                                      \ 'path':       path,
                                      \ 'buffer':     bufnr,
                                      \ 'detecting':  0,
                                      \ 'vcs':        [],
                                      \ 'hunks':      [],
                                      \ 'signid':     0x100,
                                      \ 'updated_by': '',
                                      \ 'stats':      [-1, -1, -1],
                                      \ 'info':       {
                                      \    'dir':  fnamemodify(path, ':p:h'),
                                      \    'path': sy#util#escape(path),
                                      \    'file': sy#util#escape(fnamemodify(path, ':t'))
                                      \ }}
                                call setbufvar(bufnr, 'sy', new_sy)
                                call sy#set_buflocal_autocmds(bufnr)
                                call sy#repo#detect(bufnr)
                              elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
                              else
                                let path = s:get_path(bufnr)
                                if !filereadable(path)
                                  call sy#stop()
                                  return
                                elseif empty(sy.vcs)
                                  if get(sy, 'retry')
                                    let sy.retry = 0
                                    call sy#verbose('Redetecting VCS.')
                                    call sy#repo#detect(sy.buffer)
                                  else
                                    if get(sy, 'detecting')
                                      call sy#verbose('Detection is already in progress.')
                                    else
                                      call sy#verbose('No VCS found. Disabling.')
                                      call sy#stop(sy.buffer)
                                    endif
                                  endif
                                else
                                  for vcs in sy.vcs
                                    let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
                                    if type(job_id) != type(0) || job_id > 0
                                      call sy#verbose('Update is already in progress.', vcs)
                                    else
                                      call sy#verbose('Updating signs.', vcs)
                                      call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
                                    endif
                                  endfor
                                endif
                              endif
                            endfunction
                            
                            " #stop {{{1
    1              0.000001 function! sy#stop(...) abort
                              let bufnr = bufnr('')
                              if empty(getbufvar(a:0 ? a:1 : bufnr, 'sy')) | return | endif
                              call sy#sign#remove_all_signs(bufnr)
                              execute printf('autocmd! signify * <buffer=%d>', bufnr)
                              call setbufvar(bufnr, 'sy', {})
                            endfunction
                            
                            " #toggle {{{1
    1              0.000001 function! sy#toggle() abort
                              call call(empty(getbufvar(bufnr(''), 'sy')) ? 'sy#start' : 'sy#stop', [])
                            endfunction
                            
                            " #start_all {{{1
    1              0.000001 function! sy#start_all() abort
                              for bufnr in range(1, bufnr(''))
                                call sy#start({'bufnr': bufnr})
                              endfor
                              let g:signify_disable_by_default = 0
                            endfunction
                            
                            " #stop_all {{{1
    1              0.000001 function! sy#stop_all() abort
                              for bufnr in range(1, bufnr(''))
                                if !empty(getbufvar(bufnr, 'sy'))
                                  call sy#stop(bufnr)
                                endif
                              endfor
                              let g:signify_disable_by_default = 1
                            endfunction
                            
                            " #buffer_is_active {{{1
    1              0.000001 function! sy#buffer_is_active()
                              return !empty(getbufvar(bufnr(''), 'sy'))
                            endfunction
                            
                            " #verbose {{{1
    1              0.000001 function! sy#verbose(msg, ...) abort
                              if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
                              endif
                            endfunction
                            
                            " #set_buflocal_autocmds {{{1
    1              0.000001 function! sy#set_buflocal_autocmds(bufnr) abort
                              augroup signify
                                execute printf('autocmd! * <buffer=%d>', a:bufnr)
                            
                                execute printf('autocmd BufEnter     <buffer=%d> call sy#start()', a:bufnr)
                                execute printf('autocmd WinEnter     <buffer=%d> call sy#start()', a:bufnr)
                                execute printf('autocmd BufWritePost <buffer=%d> call sy#start()', a:bufnr)
                            
                                execute printf('autocmd CursorHold   <buffer=%d> call sy#start()', a:bufnr)
                                execute printf('autocmd CursorHoldI  <buffer=%d> call sy#start()', a:bufnr)
                            
                                execute printf('autocmd FocusGained  <buffer=%d> SignifyRefresh', a:bufnr)
                            
                                execute printf('autocmd CmdwinEnter <buffer=%d> let g:signify_cmdwin_active = 1', a:bufnr)
                                execute printf('autocmd CmdwinLeave <buffer=%d> let g:signify_cmdwin_active = 0', a:bufnr)
                            
                                execute printf('autocmd ShellCmdPost <buffer=%d> call sy#start()', a:bufnr)
                            
                                if exists('##VimResume')
                                  execute printf('autocmd VimResume <buffer=%d> call sy#start()', a:bufnr)
                                endif
                              augroup END
                            
                              if exists('#User#SignifyAutocmds')
                                doautocmd <nomodeline> User SignifyAutocmds
                              endif
                            endfunction
                            
                            " s:get_path {{{1
    1              0.000004 function! s:get_path(bufnr)
                              let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
                              if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
                              endif
                              return path
                            endfunction
                            
                            " s:skip {{{1
    1              0.000002 function! s:skip(bufnr, path)
                              if getbufvar(a:bufnr, '&diff') || !filereadable(a:path)
                                return 1
                              endif
                            
                              if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, getbufvar(a:bufnr, '&filetype'))
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help')
                                      \ && getbufvar(a:bufnr, '&buftype') == 'help'
                                  return 1
                                endif
                              endif
                            
                              if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
                              endif
                            
                              " DEPRECATED: Use g:signify_skip.pattern instead.
                              if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
                              endif
                            
                              if exists('g:signify_skip')
                                if has_key(g:signify_skip, 'pattern')
                                  for pattern in g:signify_skip.pattern
                                    if a:path =~ pattern
                                      return 1
                                    endif
                                  endfor
                                endif
                              endif
                            
                              return 0
                            endfunction

SCRIPT  /Users/john/.config/nvim/autoload/plugged/vim-signify/autoload/sy/util.vim
Sourced 1 time
Total time:   0.000473
 Self time:   0.000473

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000003 scriptencoding utf-8
                            
                            " #escape {{{1
    1              0.000003 function! sy#util#escape(path) abort
                              if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
                              endif
                            
                              let path = shellescape(a:path)
                            
                              if exists('old_ssl')
                                let &shellslash = old_ssl
                              endif
                            
                              return path
                            endfunction
                            
                            " #refresh_windows {{{1
    1              0.000001 function! sy#util#refresh_windows() abort
                              " return if signify is not active
                              if empty(getbufvar(bufnr(''), 'sy'))
                                return
                              endif
                              if exists('*win_getid')
                                let winid = win_getid()
                              else
                                let winnr = winnr()
                              endif
                            
                              if !get(g:, 'signify_cmdwin_active')
                                for bufnr in tabpagebuflist()
                                  call sy#start({'bufnr': bufnr})
                                endfor
                              endif
                            
                              if exists('winid')
                                call win_gotoid(winid)
                              else
                                execute winnr .'wincmd w'
                              endif
                            endfunction
                            
                            " #hunk_text_object {{{1
    1              0.000001 function! sy#util#hunk_text_object(emptylines) abort
                              execute sy#util#return_if_no_changes()
                            
                              let lnum  = line('.')
                              let hunks = filter(copy(b:sy.hunks), 'v:val.start <= lnum && v:val.end >= lnum')
                            
                              if empty(hunks)
                                echomsg 'signify: Here is no hunk.'
                                return
                              endif
                            
                              execute hunks[0].start
                              normal! V
                            
                              if a:emptylines
                                let lnum = hunks[0].end
                                while getline(lnum+1) =~ '^$'
                                  let lnum += 1
                                endwhile
                                execute lnum
                              else
                                execute hunks[0].end
                              endif
                            endfunction
                            
                            " #shell_redirect {{{1
    1              0.000001 function! sy#util#shell_redirect(path) abort
                              " if shellredir contains a %s it is replaced with the path
                              " otherwise, just append it (from :help shellredir:
                              "   The name of the temporary file can be represented by '%s' if necessary
                              "   (the file name is appended automatically if no %s appears in the value
                              "   of this option)
                              if &shellredir =~# '%s'
                                return substitute(&shellredir, '\C%s', a:path, 'g')
                              else
                                return &shellredir .' '. a:path
                              endif
                            endfunction
                            
                            " #chdir {{{1
    1              0.000001 function! sy#util#chdir() abort
                              let chdir = haslocaldir()
                                    \ ? 'lcd'
                                    \ : (exists(':tcd') && haslocaldir(-1, 0)) ? 'tcd' : 'cd'
                              return [getcwd(), chdir]
                            endfunction
                            
                            " #return_if_no_changes {{{1
    1              0.000001 function! sy#util#return_if_no_changes() abort
                              let sy = getbufvar(bufnr(''), 'sy')
                              if empty(sy) || empty(sy.hunks)
                                echomsg 'signify: There are no changes.'
                                return 'return'
                              endif
                              return ''
                            endfunction
                            
                            " #execute {{{1
    1              0.000001 function! sy#util#execute(cmd) abort
                              let lang = v:lang
                              redir => output
                                silent! execute a:cmd
                              redir END
                              silent! execute 'language message' lang
                              return output
                            endfunction
                            
    1              0.000002 let s:popup_window = 0
                            
                            " #popup_close {{{1
    1              0.000013 function! sy#util#popup_close() abort
                              if s:popup_window
                                call nvim_win_close(s:popup_window, 1)
                                let s:popup_window = 0
                              endif
                            endfunction
                            
                            " #popup_create {{{1
    1              0.000001 function! sy#util#popup_create(hunkdiff) abort
                              let offset      = s:offset()
                              let winline     = winline()
                              let min_height  = 6
                              let max_height  = winheight('%') - winline
                              let diff_height = len(a:hunkdiff)
                              let height      = min([diff_height, max_height])
                            
                              if diff_height > max_height && max_height < min_height
                                let max_scroll = min_height - max_height
                                let scroll     = min([max_scroll, diff_height - max_height])
                                " Old versions don't have feedkeys(..., 'x')
                                execute 'normal!' scroll.''
                                let winline -= scroll
                                let height  += scroll
                              endif
                            
                              let padding = repeat(' ', offset - 1)
                            
                              if exists('*nvim_open_win')
                                call sy#util#popup_close()
                                let buf = nvim_create_buf(0, 1)
                                call nvim_buf_set_option(buf, 'syntax', 'diff')
                                call nvim_buf_set_lines(buf, 0, -1, 0, map(a:hunkdiff, 'v:val[0].padding.v:val[1:]'))
                                let s:popup_window = nvim_open_win(buf, v:false, {
                                      \ 'relative': 'win',
                                      \ 'row': winline,
                                      \ 'col': 0,
                                      \ 'width': winwidth('%'),
                                      \ 'height': height,
                                      \ })
                                call nvim_win_set_option(s:popup_window, 'cursorline', v:false)
                                call nvim_win_set_option(s:popup_window, 'foldcolumn', has('nvim-0.5') ? '0' : 0)
                                call nvim_win_set_option(s:popup_window, 'foldenable', v:false)
                                call nvim_win_set_option(s:popup_window, 'number', v:false)
                                call nvim_win_set_option(s:popup_window, 'relativenumber', v:false)
                                call nvim_win_set_option(s:popup_window, 'wrap', v:true)
                                autocmd CursorMoved * ++once call sy#util#popup_close()
                              elseif exists('*popup_create')
                                let s:popup_window = popup_create(map(a:hunkdiff, 'v:val[0].padding.v:val[1:]'), {
                                      \ 'line': 'cursor+1',
                                      \ 'col': 0,
                                      \ 'minwidth': winwidth('%'),
                                      \ 'maxheight': height,
                                      \ 'moved': 'any',
                                      \ 'zindex': 1000,
                                      \ })
                                call setbufvar(winbufnr(s:popup_window), '&syntax', 'diff')
                              else
                                return 0
                              endif
                            
                              return 1
                            endfunction
                            
                            " s:offset {{{1
    1              0.000003 function! s:offset() abort
                              let offset = &foldcolumn
                              let offset += 2  " FIXME: Find better way to calculate the sign column width.
                              if &number
                                let l = len(line('$')) + 1
                                let offset += (&numberwidth > l) ? &numberwidth : l
                              elseif &relativenumber
                                let l = len(winheight('%')) + 1
                                let offset += (&numberwidth > l) ? &numberwidth : l
                              endif
                              return offset
                            endfunction

SCRIPT  /Users/john/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim
Sourced 1 time
Total time:   0.022502
 Self time:   0.022467

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000005 scriptencoding utf-8
                            
                            " #detect {{{1
    1              0.000004 function! sy#repo#detect(bufnr) abort
                              let sy = getbufvar(a:bufnr, 'sy')
                              for vcs in s:vcs_list
                                let sy.detecting += 1
                                call sy#repo#get_diff(a:bufnr, vcs, function('sy#sign#set_signs'))
                              endfor
                            endfunction
                            
                            " s:callback_nvim_stdout{{{1
    1              0.000004 function! s:callback_nvim_stdout(_job_id, data, _event) dict abort
                              let self.stdoutbuf[-1] .= a:data[0]
                              call extend(self.stdoutbuf, a:data[1:])
                            endfunction
                            
                            " s:callback_nvim_exit {{{1
    1              0.000001 function! s:callback_nvim_exit(_job_id, exitval, _event) dict abort
                              return s:handle_diff(self, a:exitval)
                            endfunction
                            
                            " s:callback_vim_stdout {{{1
    1              0.000001 function! s:callback_vim_stdout(_job_id, data) dict abort
                              let self.stdoutbuf += [a:data]
                            endfunction
                            
                            " s:callback_vim_close {{{1
    1              0.000001 function! s:callback_vim_close(channel) dict abort
                              let job = ch_getjob(a:channel)
                              while 1
                                if job_status(job) == 'dead'
                                  let exitval = job_info(job).exitval
                                  break
                                endif
                                sleep 10m
                              endwhile
                              return s:handle_diff(self, exitval)
                            endfunction
                            
                            " s:write_buffer {{{1
    1              0.000001 function! s:write_buffer(bufnr, file)
                              let bufcontents = getbufline(a:bufnr, 1, '$')
                            
                              if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
                              if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
                              let fenc = getbufvar(a:bufnr, '&fileencoding')
                              let enc  = getbufvar(a:bufnr, '&encoding')
                              if fenc !=# enc
                                call map(bufcontents, 'iconv(v:val, "'.enc.'", "'.fenc.'")')
                              endif
                            
                              if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
                              call writefile(bufcontents, a:file)
                            endfunction
                            
                            " sy#get_diff {{{1
    1              0.000001 function! sy#repo#get_diff(bufnr, vcs, func) abort
                              call sy#verbose('sy#repo#get_diff()', a:vcs)
                            
                              let job_id = getbufvar(a:bufnr, 'sy_job_id_'.a:vcs)
                            
                              if getbufvar(a:bufnr, '&modified')
                                let [cmd, options] = s:initialize_buffer_job(a:bufnr, a:vcs)
                                let options.difftool = 'diff'
                              else
                                let [cmd, options] = s:initialize_job(a:bufnr, a:vcs)
                                let options.difftool = a:vcs
                              endif
                            
                              let options.func = a:func
                            
                              if has('nvim')
                                if job_id
                                  silent! call jobstop(job_id)
                                endif
                                let job_id = jobstart(cmd, extend(options, {
                                      \ 'cwd':       getbufvar(a:bufnr, 'sy').info.dir,
                                      \ 'on_stdout': function('s:callback_nvim_stdout'),
                                      \ 'on_exit':   function('s:callback_nvim_exit'),
                                      \ }))
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              elseif has('patch-8.0.902')
                                if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
                                endif
                                let opts = {
                                      \ 'cwd':      getbufvar(a:bufnr, 'sy').info.dir,
                                      \ 'in_io':    'null',
                                      \ 'out_cb':   function('s:callback_vim_stdout', options),
                                      \ 'close_cb': function('s:callback_vim_close', options),
                                      \ }
                                let job_id = job_start(cmd, opts)
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
                              endif
                            endfunction
                            
                            " s:handle_diff {{{1
    1              0.000004 function! s:handle_diff(options, exitval) abort
                              call sy#verbose('s:handle_diff()', a:options.vcs)
                            
                              if has_key(a:options, 'tempfiles')
                                for f in a:options.tempfiles
                                  call delete(f)
                                endfor
                              endif
                            
                              let sy = getbufvar(a:options.bufnr, 'sy')
                              if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
                              elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
                              elseif empty(sy.vcs)
                                let sy.detecting -= 1
                              endif
                            
                              let fenc = getbufvar(a:options.bufnr, '&fenc')
                              let enc  = getbufvar(a:options.bufnr, '&enc')
                              if (fenc != enc) && has('iconv')
                                call map(a:options.stdoutbuf, printf('iconv(v:val, "%s", "%s")', fenc, enc))
                              endif
                            
                              let [found_diff, diff] = s:check_diff_{a:options.difftool}(a:exitval, a:options.stdoutbuf)
                              if found_diff
                                if index(sy.vcs, a:options.vcs) == -1
                                  let sy.vcs += [a:options.vcs]
                                endif
                                call a:options.func(sy, a:options.vcs, diff)
                              else
                                call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
                              endif
                            
                              call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)
                            endfunction
                            
                            " s:check_diff_diff {{{1
    1              0.000004 function! s:check_diff_diff(exitval, diff) abort
                              return a:exitval <= 1 ? [1, a:diff] : [0, []]
                            endfunction
                            
                            " s:check_diff_git {{{1
    1              0.000002 function! s:check_diff_git(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_yadm {{{1
    1              0.000001 function! s:check_diff_yadm(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_hg {{{1
    1              0.000001 function! s:check_diff_hg(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_svn {{{1
    1              0.000001 function! s:check_diff_svn(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_bzr {{{1
    1              0.000001 function! s:check_diff_bzr(exitval, diff) abort
                              return (a:exitval =~ '[012]') ? [1, a:diff] : [0, []]
                            endfunction
                            
                            " s:check_diff_darcs {{{1
    1              0.000001 function! s:check_diff_darcs(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_fossil {{{1
    1              0.000001 function! s:check_diff_fossil(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_cvs {{{1
    1              0.000001 function! s:check_diff_cvs(exitval, diff) abort
                              let [found_diff, diff] = [0, []]
                              if a:exitval == 1
                                for diffline in a:diff
                                  if diffline =~ '^+++'
                                    let [found_diff, diff] = [1, a:diff]
                                    break
                                  endif
                                endfor
                              elseif a:exitval == 0 && len(a:diff) == 0
                                let found_diff = 1
                              endif
                              return [found_diff, diff]
                            endfunction
                            
                            " s:check_diff_rcs {{{1
    1              0.000001 function! s:check_diff_rcs(exitval, diff) abort
                              return (a:exitval == 2) ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_accurev {{{1
    1              0.000017 function! s:check_diff_accurev(exitval, diff) abort
                              return (a:exitval >= 2) ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_perforce {{{1
    1              0.000001 function! s:check_diff_perforce(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " s:check_diff_tfs {{{1
    1              0.000001 function! s:check_diff_tfs(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, s:strip_context(a:diff)]
                            endfunction
                            
                            " #get_stats {{{1
    1              0.000001 function! sy#repo#get_stats(...) abort
                              let sy = getbufvar(a:0 ? a:1 : bufnr(''), 'sy')
                              return empty(sy) ? [-1, -1, -1] : sy.stats
                            endfunction
                            
                            " #get_stats_decorated {{{1
    1              0.000001 function! sy#repo#get_stats_decorated(...)
                              let bufnr = a:0 ? a:1 : bufnr('')
                              let [added, modified, removed] = sy#repo#get_stats(bufnr)
                              let symbols = ['+', '-', '~']
                              let stats = [added, removed, modified]  " reorder
                              let statline = ''
                            
                              for i in range(3)
                                if stats[i] > 0
                                  let statline .= printf('%s%s ', symbols[i], stats[i])
                                endif
                              endfor
                            
                              if !empty(statline)
                                let statline = printf('[%s]', statline[:-2])
                              endif
                            
                              return statline
                            endfunction
                            
                            " #debug_detection {{{1
    1              0.000001 function! sy#repo#debug_detection()
                              if empty(getbufvar(bufnr(''), 'sy'))
                                echomsg 'signify: I cannot detect any changes!'
                                return
                              endif
                            
                              for vcs in s:vcs_list
                                let cmd = s:get_base_cmd(bufnr(''), vcs, g:signify_vcs_cmds)
                                echohl Statement
                                echo cmd
                                echo repeat('=', len(cmd))
                                echohl NONE
                            
                                let diff = s:run(vcs)
                                if v:shell_error
                                  echohl ErrorMsg
                                  echo diff
                                  echohl NONE
                                else
                                  echo empty(diff) ? "<none>" : diff
                                endif
                                echo "\n"
                              endfor
                            endfunction
                            
    1              0.000001 function! s:system_in_dir(cmd) abort
                              let [cwd, chdir] = sy#util#chdir()
                              try
                                execute chdir fnameescape(b:sy.info.dir)
                                return system(a:cmd)
                              finally
                                execute chdir fnameescape(cwd)
                              endtry
                            endfunction
                            
                            " #diffmode {{{1
    1              0.000062 function! sy#repo#diffmode(do_tab) abort
                              execute sy#util#return_if_no_changes()
                            
                              let vcs = b:sy.updated_by
                            
                              call sy#verbose('SignifyDiff', vcs)
                              let ft = &filetype
                              let fenc = &fenc
                              if a:do_tab
                                tabedit %
                              endif
                              diffthis
                            
                              let base = s:get_base(bufnr(''), vcs)
                            
                              leftabove vnew
                              if (fenc != &enc) && has('iconv')
                                silent put =iconv(base, fenc, &enc)
                              else
                                silent put =base
                              endif
                            
                              silent 1delete
                              set buftype=nofile bufhidden=wipe nomodified
                              let &filetype = ft
                              diffthis
                              wincmd p
                              normal! ]czt
                            endfunction
                            
                            " s:extract_current_hunk {{{1
    1              0.000003 function! s:extract_current_hunk(diff) abort
                              let header = ''
                              let hunk = []
                            
                              for line in a:diff
                                if header != ''
                                  if line[:2] == '@@ ' || empty(line)
                                    break
                                  endif
                                  call add(hunk, line)
                                elseif line[:2] == '@@ ' && s:is_cur_line_in_hunk(line)
                                  let header = line
                                endif
                              endfor
                            
                              return [header, hunk]
                            endfunction
                            
    1              0.000001 function! s:is_cur_line_in_hunk(hunkline) abort
                              let cur_line = line('.')
                              let [_old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(a:hunkline)
                            
                              if cur_line == 1 && new_line == 0
                                " deleted first line
                                return 1
                              endif
                            
                              if cur_line == new_line && new_count < old_count
                                " deleted lines
                                return 1
                              endif
                            
                              if cur_line >= new_line && cur_line < (new_line + new_count)
                                " added/changed lines
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            " #diff_hunk {{{1
    1              0.000001 function! sy#repo#diff_hunk() abort
                              let bufnr = bufnr('')
                              let sy = getbufvar(bufnr, 'sy')
                              if !empty(sy) && !empty(sy.updated_by)
                                call sy#repo#get_diff(bufnr, sy.updated_by, function('s:diff_hunk'))
                              endif
                            endfunction
                            
    1              0.000001 function! s:diff_hunk(_sy, vcs, diff) abort
                              call sy#verbose('s:preview_hunk()', a:vcs)
                            
                              let [_, hunk] = s:extract_current_hunk(a:diff)
                              if empty(hunk)
                                return
                              endif
                            
                              if sy#util#popup_create(hunk)
                                return
                              endif
                            
                              silent! wincmd P
                              if !&previewwindow
                                noautocmd botright new
                              endif
                              call setline(1, hunk)
                              silent! %foldopen!
                              setlocal previewwindow filetype=diff buftype=nofile bufhidden=delete
                              " With :noautocmd wincmd p, the first line of the preview window would show
                              " the 'cursorline', although it's not focused. Use feedkeys() instead.
                              noautocmd call feedkeys("\<c-w>p", 'nt')
                            endfunction
                            
                            " #undo_hunk {{{1
    1              0.000001 function! sy#repo#undo_hunk() abort
                              let bufnr = bufnr('')
                              let sy = getbufvar(bufnr, 'sy')
                              if !empty(sy) && !empty(sy.updated_by)
                                call sy#repo#get_diff(bufnr, sy.updated_by, function('s:undo_hunk'))
                              endif
                            endfunction
                            
    1              0.000001 function! s:undo_hunk(sy, vcs, diff) abort
                              call sy#verbose('s:undo_hunk()', a:vcs)
                            
                              let [header, hunk] = s:extract_current_hunk(a:diff)
                              if empty(hunk)
                                return
                              endif
                            
                              let [_old_line, _old_count, new_line, new_count] = sy#sign#parse_hunk(header)
                            
                              for line in hunk
                                let op = line[0]
                                let text = line[1:]
                                if op == ' '
                                  if text != getline(new_line)
                                    echoerr 'Could not apply context hunk for undo. Try saving the buffer first.'
                                    return
                                  endif
                                  let new_line += 1
                                elseif op == '-'
                                  call append(new_count == 0 ? new_line : new_line - 1, text)
                                  let new_line += 1
                                elseif op == '+'
                                  if text != getline(new_line)
                                    echoerr 'Could not apply addition hunk for undo. Try saving the buffer first.'
                                    return
                                  endif
                                  execute 'silent' new_line 'delete _'
                                else
                                  echoer 'Unknown diff operation ' . line
                                  return
                                endif
                              endfor
                            
                              " Undoing altered the buffer, so update signs.
                              call setbufvar(a:sy.buffer, 'sy_job_id_'.a:vcs, 0)
                              return sy#start()
                            endfunction
                            
                            " s:initialize_job {{{1
    1              0.000001 function! s:initialize_job(bufnr, vcs) abort
                              return s:wrap_cmd(a:bufnr, a:vcs, s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds))
                            endfunction
                            
                            " s:initialize_buffer_job {{{1
    1              0.000001 function! s:initialize_buffer_job(bufnr, vcs) abort
                              let bufferfile = tempname()
                              call s:write_buffer(a:bufnr, bufferfile)
                            
                              let basefile = tempname()
                              let base_cmd = s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds_diffmode) . '>' . fnameescape(basefile) . ' && '
                            
                              let diff_cmd = base_cmd .  s:difftool . ' -U0 ' . fnameescape(basefile) . ' ' . fnameescape(bufferfile)
                              let [cmd, options] = s:wrap_cmd(a:bufnr, a:vcs, diff_cmd)
                            
                              let options.tempfiles = [basefile, bufferfile]
                            
                              return [cmd, options]
                            endfunction
                            
                            " s:wrap_cmd {{{1
    1              0.000199 function! s:wrap_cmd(bufnr, vcs, cmd) abort
                              if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell)' ? a:cmd : ['sh', '-c', a:cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', a:cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, a:cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, a:cmd, &shellxquote])
                                  endif
                                endif
                              else
                                let cmd = ['sh', '-c', a:cmd]
                              endif
                              let options = {
                                    \ 'stdoutbuf': [''],
                                    \ 'vcs': a:vcs,
                                    \ 'bufnr': a:bufnr,
                                    \ }
                              return [cmd, options]
                            endfunction
                            
                            " s:get_vcs_path {{{1
    1              0.000002 function! s:get_vcs_path(bufnr, vcs) abort
                              return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)')
                                    \ ? getbufvar(a:bufnr, 'sy').info.file
                                    \ : getbufvar(a:bufnr, 'sy').info.path
                            endfunction
                            
                            " s:get_base_cmd {{{1
    1              0.000002 function! s:get_base_cmd(bufnr, vcs, vcs_cmds) abort
                              let cmd = a:vcs_cmds[a:vcs]
                              let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:bufnr, a:vcs))
                              let cmd = s:replace(cmd, '%d', s:difftool)
                              let cmd = s:replace(cmd, '%n', s:devnull)
                              return cmd
                            endfunction
                            
                            " s:get_base {{{1
                            " Get the "base" version of the current buffer as a string.
    1              0.000001 function! s:get_base(bufnr, vcs) abort
                              return s:system_in_dir(s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds_diffmode))
                            endfunction
                            
                            " s:run {{{1
    1              0.000001 function! s:run(vcs)
                              try
                                let ret = s:system_in_dir(s:get_base_cmd(bufnr(''), a:vcs, g:signify_vcs_cmds))
                              catch
                                " This exception message can be seen via :SignifyDebugUnknown.
                                " E.g. unquoted VCS programs in vcd_cmds can lead to E484.
                                let ret = v:exception .' at '. v:throwpoint
                              finally
                                return ret
                              endtry
                            endfunction
                            
                            " s:replace {{{1
    1              0.000001 function! s:replace(cmd, pat, sub)
                              let parts = split(a:cmd, a:pat, 1)
                              return join(parts, a:sub)
                            endfunction
                            
                            " s:strip_context {{{1
    1              0.000001 function! s:strip_context(context)
                              let diff = []
                              let hunk = []
                              let state = 0
                              let lines = a:context
                              let linenr = 0
                            
                              while linenr < len(lines)
                                let line = lines[linenr]
                            
                                if state == 0
                                  if line =~ "^@@ "
                                    let [old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(line)
                                    let hunk = []
                                    let state = 1
                                  else
                                    call add(diff,line)
                                  endif
                                  let linenr += 1
                                elseif index([1,2,3],state) >= 0 && index(['\','/'],line[0]) >= 0
                                  let linenr += 1
                                  call add(hunk,line)
                                elseif state == 1
                                  if line[0] == ' '
                                    let old_line += 1
                                    let new_line += 1
                                    let old_count -= 1
                                    let new_count -= 1
                                    let linenr += 1
                                  else
                                    let old_count_part = 0
                                    let new_count_part = 0
                                    let state = 2
                                  endif
                                elseif state == 2
                                  if line[0] == '-'
                                    call add(hunk,line)
                                    let old_count_part += 1
                                    let linenr += 1
                                  else
                                    let state = 3
                                  endif
                                elseif state == 3
                                  if line[0] == '+'
                                    call add(hunk,line)
                                    let new_count_part += 1
                                    let linenr += 1
                                  else
                                    call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                    let diff += hunk
                                    let hunk = []
                                    let old_count -= old_count_part
                                    let new_count -= new_count_part
                                    let old_line += old_count_part
                                    let new_line += new_count_part
                                    let state = 1
                                  endif
                                endif
                            
                                if state > 0 && new_count <= 0 && old_count <= 0
                                  if len(hunk) > 0
                                    call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                    let diff = diff + hunk
                                    let hunk = []
                                  endif
                                  let state = 0
                                endif
                              endwhile
                              if len(hunk) > 0
                                call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                let diff = diff + hunk
                                let hunk = []
                              endif
                              return diff
                            endfunction
                            " 1}}}
                            
                            " Variables {{{1
    1   0.000111   0.000093 let s:default_vcs_cmds = {
                                  \ 'git':      'git diff --no-color --no-ext-diff -U0 -- %f',
                                  \ 'yadm':     'yadm diff --no-color --no-ext-diff -U0 -- %f',
                                  \ 'hg':       'hg diff --color=never --config aliases.diff= --nodates -U0 -- %f',
                                  \ 'svn':      'svn diff --diff-cmd %d -x -U0 -- %f',
                                  \ 'bzr':      'bzr diff --using %d --diff-options=-U0 -- %f',
                                  \ 'darcs':    'darcs diff --no-pause-for-gui --no-unified --diff-opts=-U0 -- %f',
                                  \ 'fossil':   'fossil diff --unified -c 0 -- %f',
                                  \ 'cvs':      'cvs diff -U0 -- %f',
                                  \ 'rcs':      'rcsdiff -U0 %f 2>%n',
                                  \ 'accurev':  'accurev diff %f -- -U0',
                                  \ 'perforce': 'p4 info '. sy#util#shell_redirect('%n') . (has('win32') ? ' &&' : ' && env P4DIFF= P4COLORS=') .' p4 diff -du0 %f',
                                  \ 'tfs':      'tf diff -version:W -noprompt -format:Unified %f'
                                  \ }
                            
    1              0.000015 let s:default_vcs_cmds_diffmode = {
                                  \ 'git':      'git show HEAD:./%f',
                                  \ 'yadm':     'yadm show HEAD:./%f',
                                  \ 'hg':       'hg cat %f',
                                  \ 'svn':      'svn cat %f',
                                  \ 'bzr':      'bzr cat %f',
                                  \ 'darcs':    'darcs show contents -- %f',
                                  \ 'fossil':   'fossil cat %f',
                                  \ 'cvs':      'cvs up -p -- %f 2>%n',
                                  \ 'rcs':      'co -q -p %f',
                                  \ 'accurev':  'accurev cat %f',
                                  \ 'perforce': 'p4 print %f',
                                  \ 'tfs':      'tf view -version:W -noprompt %f',
                                  \ }
                            
    1              0.000003 if exists('g:signify_vcs_cmds')
                              call extend(g:signify_vcs_cmds, s:default_vcs_cmds, 'keep')
    1              0.000014 else
    1              0.000002   let g:signify_vcs_cmds = s:default_vcs_cmds
    1              0.000001 endif
    1              0.000002 if exists('g:signify_vcs_cmds_diffmode')
                              call extend(g:signify_vcs_cmds_diffmode, s:default_vcs_cmds_diffmode, 'keep')
    1              0.000001 else
    1              0.000002   let g:signify_vcs_cmds_diffmode = s:default_vcs_cmds_diffmode
    1              0.000001 endif
                            
    1              0.000200 let s:vcs_dict = map(copy(g:signify_vcs_cmds), 'split(v:val)[0]')
                            
    1              0.000004 if exists('g:signify_skip') && has_key(g:signify_skip, 'vcs')
                              if has_key(g:signify_skip.vcs, 'allow')
                                let s:vcs_list = filter(copy(g:signify_skip.vcs.allow), 'executable(s:vcs_dict[v:val])')
                              elseif has_key(g:signify_skip.vcs, 'deny')
                                for vcs in g:signify_skip.vcs.deny
                                  silent! call remove(s:vcs_dict, vcs)
                                endfor
                                let s:vcs_list = keys(filter(s:vcs_dict, 'executable(v:val)'))
                              end
    1              0.000001 else
    1              0.001350   let s:vcs_list = keys(filter(s:vcs_dict, 'executable(v:val)'))
    1              0.000001 endif
                            
    1   0.000027   0.000010 let s:difftool = sy#util#escape(get(g:, 'signify_difftool', 'diff'))
    1              0.000008 let s:devnull  = has('win32') || has ('win64') ? 'NUL' : '/dev/null'

SCRIPT  /Users/john/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim
Sourced 1 time
Total time:   0.000752
 Self time:   0.000752

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2021 Christian Brabandt et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003 scriptencoding utf-8
                            
    1              0.000007 let s:untracked_jobs = {}
    1              0.000001 let s:mq_jobs        = {}
    1              0.000001 let s:po_jobs        = {}
    1              0.000001 let s:clean_jobs     = {}
                            
                            " Generic functions handling on exit event of the various async functions
    1              0.000003 function! s:untracked_output(dict, buf)
                              if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif
                            endfunction
                            
                            " also called from branch extension (for non-async vims)
    1              0.000002 function! airline#async#mq_output(buf, file)
                              let buf=a:buf
                              if !empty(a:buf)
                                if a:buf =~# 'no patches applied' ||
                                  \ a:buf =~# "unknown command 'qtop'" ||
                                  \ a:buf =~# "abort"
                                  let buf = ''
                                elseif exists("b:mq") && b:mq isnot# buf
                                  " make sure, statusline is updated
                                  unlet! b:airline_head
                                endif
                                let b:mq = buf
                              endif
                              if has_key(s:mq_jobs, a:file)
                                call remove(s:mq_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000002 function! s:po_output(buf, file)
                              if !empty(a:buf)
                                let b:airline_po_stats = printf("%s", a:buf)
                              else
                                let b:airline_po_stats = ''
                              endif
                              if has_key(s:po_jobs, a:file)
                                call remove(s:po_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000001 function! s:valid_dir(dir)
                              if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
                              return a:dir
                            endfunction
                            
    1              0.000002 function! airline#async#vcs_untracked(config, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
                              else
                                " nvim async or vim without job-feature
                                noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000002 function! s:set_clean_variables(file, vcs, val)
                              let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
                              if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') &&
                                    \ type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
                                let var[a:vcs].dirty=a:val
                                try
                                  call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
                                  unlet! b:airline_head
                                catch
                                endtry
                              endif
                            endfunction
                            
    1              0.000001 function! s:set_clean_jobs_variable(vcs, file, id)
                              if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
                              endif
                              let s:clean_jobs[a:vcs][a:file]=a:id
                            endfunction
                            
    1              0.000001 function! s:on_exit_clean(...) dict abort
                              let buf=self.buf
                              call s:set_clean_variables(self.file, self.vcs, !empty(buf))
                              if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
                                call remove(s:clean_jobs[self.vcs], self.file)
                              endif
                            endfunction
                            
    1              0.000001 function! airline#async#vcs_clean(cmd, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                              elseif has("nvim")
                                " nvim async
                                noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000005 if v:version >= 800 && has("job")
                              " Vim 8.0 with Job feature
                              " TODO: Check if we need the cwd option for the job_start() functions
                              "       (only works starting with Vim 8.0.0902)
                            
                              function! s:on_stdout(channel, msg) dict abort
                                let self.buf .= a:msg
                              endfunction
                            
                              function! s:on_exit_mq(channel) dict abort
                                call airline#async#mq_output(self.buf, self.file)
                              endfunction
                            
                              function! s:on_exit_untracked(channel) dict abort
                                call s:untracked_output(self, self.buf)
                                if has_key(s:untracked_jobs, self.file)
                                  call remove(s:untracked_jobs, self.file)
                                endif
                              endfunction
                            
                              function! s:on_exit_po(channel) dict abort
                                call s:po_output(self.buf, self.file)
                                call airline#extensions#po#shorten()
                              endfunction
                            
                              function! airline#async#get_mq_async(cmd, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'cmd': a:cmd, 'buf': '', 'file': a:file}
                                if has_key(s:mq_jobs, a:file)
                                  if job_status(get(s:mq_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:mq_jobs, a:file)
                                    call remove(s:mq_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_mq', options)})
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#get_msgfmt_stat(cmd, file)
                                if !executable('msgfmt')
                                  " no msgfmt
                                  return
                                endif
                                if g:airline#init#is_windows
                                  let cmd = 'cmd /C ' . a:cmd. shellescape(a:file)
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                let options = {'buf': '', 'file': a:file}
                                if has_key(s:po_jobs, a:file)
                                  if job_status(get(s:po_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:po_jobs, a:file)
                                    call remove(s:po_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_po', options)})
                                let s:po_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#vim_vcs_clean(cmd, file, vcs)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'buf': '', 'vcs': a:vcs, 'file': a:file}
                                let jobs = get(s:clean_jobs, a:vcs, {})
                                if has_key(jobs, a:file)
                                  if job_status(get(jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(jobs, a:file)
                                    " still running
                                    return
                                    " jobs dict should be cleaned on exit, so not needed here
                                    " call remove(jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'null',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_clean', options)})
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
                              function! airline#async#vim_vcs_untracked(config, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
                                  let cmd = [&shell, &shellcmdflag, a:config['cmd'] . shellescape(a:file)]
                                endif
                            
                                let options = {'cfg': a:config, 'buf': '', 'file': a:file}
                                if has_key(s:untracked_jobs, a:file)
                                  if job_status(get(s:untracked_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_untracked', options)})
                                let s:untracked_jobs[a:file] = id
                              endfunction
                            
    1              0.000017 elseif has("nvim")
                              " NVim specific functions
                            
    1              0.000003   function! s:nvim_output_handler(job_id, data, event) dict
                                if a:event == 'stdout' || a:event == 'stderr'
                                  let self.buf .=  join(a:data)
                                endif
                              endfunction
                            
    1              0.000002   function! s:nvim_untracked_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:untracked_output(self, self.buf)
                                  if has_key(s:untracked_jobs, self.file)
                                    call remove(s:untracked_jobs, self.file)
                                  endif
                                endif
                              endfunction
                            
    1              0.000001   function! s:nvim_mq_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call airline#async#mq_output(self.buf, self.file)
                                endif
                              endfunction
                            
    1              0.000001   function! s:nvim_po_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:po_output(self.buf, self.file)
                                  call airline#extensions#po#shorten()
                                endif
                              endfunction
                            
    1              0.000001   function! airline#async#nvim_get_mq_async(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_mq_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if has_key(s:mq_jobs, a:file)
                                  call remove(s:mq_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
    1              0.000002   function! airline#async#nvim_get_msgfmt_stat(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_po_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd. shellescape(a:file)]
                                endif
                            
                                if has_key(s:po_jobs, a:file)
                                  call remove(s:po_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:po_jobs[a:file] = id
                              endfunction
                            
    1              0.000002   function! airline#async#nvim_vcs_clean(cmd, file, vcs)
                                let config = {
                                \ 'buf': '',
                                \ 'vcs': a:vcs,
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:on_exit_clean')}
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if !has_key(s:clean_jobs, a:vcs)
                                  let s:clean_jobs[a:vcs] = {}
                                endif
                                if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
                                  return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
                                endif
                                let id = jobstart(cmd, config)
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
    1              0.000001 endif
                            
                            " Should work in either Vim pre 8 or Nvim
    1              0.000001 function! airline#async#nvim_vcs_untracked(cfg, file, vcs)
                              let cmd = a:cfg.cmd . shellescape(a:file)
                              let id = -1
                              let config = {
                              \ 'buf': '',
                              \ 'vcs': a:vcs,
                              \ 'cfg': a:cfg,
                              \ 'file': a:file,
                              \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h'))
                              \ }
                              if has("nvim")
                                call extend(config, {
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_untracked_job_handler')})
                                if has_key(s:untracked_jobs, config.file)
                                  " still running
                                  return
                                endif
                                try
                                let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
                                endtry
                                let s:untracked_jobs[a:file] = id
                              endif
                              " vim without job feature or nvim jobstart failed
                              if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000002 function! airline#async#vim7_vcs_clean(cmd, file, vcs)
                              " Vim pre 8, fallback using system()
                              " don't want to to see error messages
                              if g:airline#init#is_windows && &shell =~ 'cmd'
                                let cmd = a:cmd .' 2>nul'
                              elseif g:airline#init#is_windows && &shell =~ 'powerline'
                                let cmd = a:cmd .' 2> $null'
                              else
                                let cmd = a:cmd .' 2>/dev/null'
                              endif
                              let output=system(cmd)
                              call s:set_clean_variables(a:file, a:vcs, !empty(output))
                            endfunction

SCRIPT  /Users/john/.config/nvim/autoload/plugged/vim-signify/autoload/sy/sign.vim
Sourced 1 time
Total time:   0.001479
 Self time:   0.001479

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000003 scriptencoding utf-8
                            
                            " Variables {{{1
    1              0.000005 if get(g:, 'signify_sign_show_text', 1)
    1              0.000004   let s:sign_delete = get(g:, 'signify_sign_delete', '_')
                            else
                              let s:sign_delete = ' '
    1              0.000001 endif
                            
                            " Support for sign priority was added together with sign_place().
    1              0.000003 if exists('*sign_place')
    1              0.000005   let s:sign_priority = printf('priority=%d', get(g:, 'signify_priority', 10))
                            else
                              let s:sign_priority = ''
    1              0.000001 endif
                            
    1              0.000003 let s:sign_show_count  = get(g:, 'signify_sign_show_count', 1)
    1              0.000002 let s:delete_highlight = ['', 'SignifyLineDelete']
                            " 1}}}
                            
                            " #id_next {{{1
    1              0.000002 function! sy#sign#id_next(sy) abort
                              let id = a:sy.signid
                              let a:sy.signid += 1
                              return id
                            endfunction
                            
                            " #get_current_signs {{{1
    1              0.000002 function! sy#sign#get_current_signs(sy) abort
                              let a:sy.internal = {}
                              let a:sy.external = {}
                            
                              let signlist = sy#util#execute('sign place buffer='. a:sy.buffer)
                            
                              for signline in split(signlist, '\n')[2:]
                                let tokens = matchlist(signline, '\v^\s+\S+\=(\d+)\s+\S+\=(\d+)\s+\S+\=(.*)$')
                                let line   = str2nr(tokens[1])
                                let id     = str2nr(tokens[2])
                                let type   = tokens[3]
                            
                                if type =~# '^Signify'
                                  " Handle ambiguous signs. Assume you have signs on line 3 and 4.
                                  " Removing line 3 would lead to the second sign to be shifted up
                                  " to line 3. Now there are still 2 signs, both one line 3.
                                  if has_key(a:sy.internal, line)
                                    execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
                                  endif
                                  let a:sy.internal[line] = { 'type': type, 'id': id }
                                else
                                  let a:sy.external[line] = id
                                endif
                              endfor
                            endfunction
                            
                            
                            " #process_diff {{{1
    1              0.000002 function! sy#sign#process_diff(sy, vcs, diff) abort
                              let a:sy.signtable             = {}
                              let a:sy.hunks                 = []
                              let [added, modified, deleted] = [0, 0, 0]
                            
                              call sy#sign#get_current_signs(a:sy)
                            
                              " Determine where we have to put our signs.
                              for line in filter(a:diff, 'v:val =~ "^@@ "')
                                let a:sy.lines = []
                                let ids        = []
                            
                                let [old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(line)
                            
                                " Workaround for non-conventional diff output in older Fossil versions:
                                " https://fossil-scm.org/forum/forumpost/834ce0f1e1
                                " Fixed as of: https://fossil-scm.org/index.html/info/7fd2a3652ea7368a
                                if a:vcs == 'fossil' && new_line == 0
                                  let new_line = old_line - 1 - deleted
                                endif
                            
                                " Pure add:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
                                if old_count == 0 && new_count > 0
                                  let added += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                  endwhile
                            
                                " Pure delete
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
                                elseif old_count > 0 && new_count == 0
                                  if s:external_sign_present(a:sy, new_line) | continue | endif
                                  let deleted += old_count
                                  if new_line == 0
                                    call add(ids, s:add_sign(a:sy, 1, 'SignifyRemoveFirstLine'))
                                  elseif s:sign_show_count
                                    let text = s:sign_delete . (old_count <= 99 ? old_count : '>')
                                    while strwidth(text) > 2
                                      let text = substitute(text, '.', '', '')
                                    endwhile
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDelete'. old_count, text))
                                  else
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDeleteMore', s:sign_delete))
                                  endif
                                " All lines are modified.
                                elseif old_count > 0 && new_count > 0 && old_count == new_count
                                  let modified += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
                                " Some lines are modified and some new lines are added.
                                elseif old_count > 0 && new_count > 0 && old_count < new_count
                                  let modified += old_count
                                  let added += new_count - old_count
                                  let offset = 0
                                  while offset < old_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                  endwhile
                                " Some lines are modified and some lines are deleted.
                                elseif old_count > 0 && new_count > 0 && old_count > new_count
                                  let modified += new_count
                                  let deleted_count = old_count - new_count
                                  let deleted += deleted_count
                            
                                  let prev_line_available = new_line > 1 && !get(a:sy.signtable, new_line - 1, 0)
                                  if prev_line_available
                                    if s:sign_show_count
                                      let text = s:sign_delete . (deleted_count <= 99 ? deleted_count : '>')
                                      while strwidth(text) > 2
                                        let text = substitute(text, '.', '', '')
                                      endwhile
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDelete'. deleted_count, text))
                                    else
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDeleteMore', s:sign_delete))
                                    endif
                                  endif
                            
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    if !prev_line_available && offset == 0
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChangeDelete'))
                                    else
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                    endif
                                    let offset += 1
                                  endwhile
                                endif
                            
                                if !empty(ids)
                                  call add(a:sy.hunks, {
                                        \ 'ids'  : ids,
                                        \ 'start': a:sy.lines[0],
                                        \ 'end'  : a:sy.lines[-1] })
                                endif
                              endfor
                            
                              " Remove obsoleted signs.
                              for line in filter(keys(a:sy.internal), '!has_key(a:sy.signtable, v:val)')
                                execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
                              endfor
                            
                              if empty(a:sy.updated_by) && empty(a:sy.hunks)
                                call sy#verbose('Successful exit value, but no diff. Keep VCS for time being.', a:vcs)
                                return
                              endif
                            
                              call sy#verbose('Signs updated.', a:vcs)
                              let a:sy.updated_by = a:vcs
                              if len(a:sy.vcs) > 1
                                call sy#verbose('Disable all other VCS.', a:vcs)
                                let a:sy.vcs = [a:vcs]
                              endif
                            
                              let a:sy.stats = [added, modified, deleted]
                            endfunction
                            
                            " #remove_all_signs {{{1
    1              0.000003 function! sy#sign#remove_all_signs(bufnr) abort
                              let sy = getbufvar(a:bufnr, 'sy', {})
                            
                              for hunk in get(sy, 'hunks', [])
                                for id in get(hunk, 'ids', [])
                                  execute 'sign unplace' id 'buffer='.a:bufnr
                                endfor
                              endfor
                            
                              let sy.hunks = []
                            endfunction
                            
                            " #parse_hunk {{{1
                            " Parse a hunk as '@@ -273,3 +267,14' into [old_line, old_count, new_line, new_count]
    1              0.000002 function! sy#sign#parse_hunk(diffline) abort
                              let tokens = matchlist(a:diffline, '^@@ -\v(\d+),?(\d*) \+(\d+),?(\d*)')
                              return [
                                    \ str2nr(tokens[1]),
                                    \ empty(tokens[2]) ? 1 : str2nr(tokens[2]),
                                    \ str2nr(tokens[3]),
                                    \ empty(tokens[4]) ? 1 : str2nr(tokens[4])
                                    \ ]
                            endfunction
                            
                            " #set_signs {{{1
    1              0.000002 function! sy#sign#set_signs(sy, vcs, diff) abort
                              call sy#verbose('sy#sign#set_signs()', a:vcs)
                            
                              if a:sy.stats == [-1, -1, -1]
                                let a:sy.stats = [0, 0, 0]
                              endif
                            
                              if empty(a:diff)
                                call sy#verbose('No changes found.', a:vcs)
                                let a:sy.stats = [0, 0, 0]
                                call sy#sign#remove_all_signs(a:sy.buffer)
                                return
                              endif
                            
                              if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
                              else
                                call sy#highlight#line_disable()
                              endif
                            
                              call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
                              if exists('#User#Signify')
                                doautocmd <nomodeline> User Signify
                              endif
                            endfunction
                            
                            " s:add_sign {{{1
    1              0.000003 function! s:add_sign(sy, line, type, ...) abort
                              call add(a:sy.lines, a:line)
                              let a:sy.signtable[a:line] = 1
                            
                              if has_key(a:sy.internal, a:line)
                                " There is a sign on this line already.
                                if a:type == a:sy.internal[a:line].type
                                  " Keep current sign since the new one is of the same type.
                                  return a:sy.internal[a:line].id
                                else
                                  " Update sign by overwriting the ID of the current sign.
                                  let id = a:sy.internal[a:line].id
                                endif
                              endif
                            
                              if !exists('id')
                                let id = sy#sign#id_next(a:sy)
                              endif
                            
                              if a:type =~# 'SignifyDelete'
                                execute printf('sign define %s text=%s texthl=SignifySignDelete linehl=%s',
                                      \ a:type,
                                      \ a:1,
                                      \ s:delete_highlight[g:signify_line_highlight])
                              endif
                              execute printf('sign place %d line=%d name=%s %s buffer=%s',
                                    \ id,
                                    \ a:line,
                                    \ a:type,
                                    \ s:sign_priority,
                                    \ a:sy.buffer)
                            
                              return id
                            endfunction
                            
                            " s:external_sign_present {{{1
    1              0.000002 function! s:external_sign_present(sy, line) abort
                              " If sign priority is supported, so are multiple signs per line.
                              " Therefore, we can report no external signs present and let
                              " g:signify_priority control whether Sy's signs are shown.
                              if !empty(s:sign_priority)
                                return
                              endif
                              if has_key(a:sy.external, a:line)
                                if has_key(a:sy.internal, a:line)
                                  " Remove Sy signs from lines with other signs.
                                  execute 'sign unplace' a:sy.internal[a:line].id 'buffer='.a:sy.buffer
                                endif
                                return 1
                              endif
                            endfunction

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:215
Called 1 time
Total time:   0.000864
 Self time:   0.000612

count  total (s)   self (s)
    1   0.000014   0.000008   let path = s:Slash(a:path)
    1              0.000010   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    1              0.000002   elseif empty(path)
                                return ''
    1              0.000011   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    1              0.000000   else
    1              0.000014     let path = fnamemodify(path, ':p:h:s?/$??')
    1              0.000001   endif
    1              0.000011   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    1              0.000003   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    1              0.000000   endif
    1              0.000019   let root = resolve(path)
    1              0.000001   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    1              0.000000   endif
    1              0.000001   let previous = ""
    1              0.000009   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    1   0.000017   0.000008   call s:Tree(env_git_dir)
    7              0.000009   while root !=# previous
    6              0.000030     if root =~# '\v^//%([^/]+/?)?$'
                                  break
    6              0.000002     endif
    6   0.000189   0.000064     if index(s:CeilingDirectories(), root) >= 0
                                  break
    6              0.000002     endif
    6              0.000020     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
    6              0.000013     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
    6              0.000002     endif
    6              0.000036     let dir = substitute(root, '[\/]$', '', '') . '/.git'
    6              0.000070     let type = getftype(dir)
    6              0.000011     if type ==# 'dir' && FugitiveIsGitDir(dir)
                                  return dir
    6              0.000009     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
    6              0.000008     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
    6   0.000162   0.000050     elseif FugitiveIsGitDir(root)
                                  return root
    6              0.000003     endif
    6              0.000006     let previous = root
    6              0.000014     let root = fnamemodify(root, ':h')
    7              0.000007   endwhile
    1              0.000001   return ''

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 9 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    9              0.000051   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    9              0.000004   endif

FUNCTION  5()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:8
Called 21 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
   21              0.000058   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  7()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:17
Called 102 times
Total time:   0.000370
 Self time:   0.000370

count  total (s)   self (s)
  102              0.000324   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>64_CeilingDirectories()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:198
Called 6 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    6              0.000013   if !exists('s:ceiling_directories')
    1              0.000003     let s:ceiling_directories = []
    1              0.000001     let resolve = 1
    2              0.000011     for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
    1              0.000002       if empty(dir)
    1              0.000001         let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
    1              0.000000       endif
    2              0.000002     endfor
    6              0.000003   endif
    6              0.000017   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:93
Called 15 times
Total time:   0.013056
 Self time:   0.001328

count  total (s)   self (s)
   93              0.000110     for Fn in a:list
   93   0.012621   0.000893       let code = call(Fn, a:000)
   93              0.000097       if code != 0
   15              0.000010         return code
   78              0.000043       endif
   78              0.000046     endfor
                                return 0

FUNCTION  airline#check_mode()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline.vim:199
Called 56 times
Total time:   0.168564
 Self time:   0.006534

count  total (s)   self (s)
   56              0.000171   if !has_key(s:contexts, a:winnr)
                                return ''
   56              0.000034   endif
   56              0.000184   let context = s:contexts[a:winnr]
                            
   56              0.000129   if get(w:, 'airline_active', 1)
   55              0.000139     let l:m = mode(1)
   55              0.000097     if l:m ==# "i"
                                  let l:mode = ['insert']
   55              0.000124     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
   55              0.000047     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   55              0.000050     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   55              0.000493     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   55              0.000076     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   55              0.000048     elseif l:m[0] ==# "c"
    5              0.000007       let l:mode = ['commandline']
   50              0.000071     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
   50              0.000059     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['insert']
                                  let l:m = 'ni'
   50              0.000022     else
   50              0.000095       let l:mode = ['normal']
   55              0.000036     endif
   55              0.000211     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
   55              0.000020     endif
   55              0.000304     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
   55              0.000082       let l:m = l:m[0]
   55              0.000020     endif
   55              0.000192     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
    1              0.000000   else
    1              0.000001     let l:mode = ['inactive']
    1              0.000003     let w:airline_current_mode = get(g:airline_mode_map, '__')
   56              0.000042   endif
                            
   56              0.000148   if g:airline_detect_modified && &modified
    6              0.000016     call add(l:mode, 'modified')
   56              0.000033   endif
                            
   56              0.000112   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
   56              0.000031   endif
                            
   56              0.000326   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
   56              0.000018   endif
                            
   56              0.000065   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
   56              0.000016   endif
                            
   56              0.000055   if &readonly || ! &modifiable
   17              0.000038     call add(l:mode, 'readonly')
   56              0.000018   endif
                            
   56              0.000202   let mode_string = join(l:mode)
   56              0.000183   if get(w:, 'airline_lastmode', '') != mode_string
   14   0.004523   0.000161     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   14   0.156124   0.000247     call airline#highlighter#highlight(l:mode, context.bufnr)
   14   0.001910   0.000119     call airline#util#doautocmd('AirlineModeChanged')
   14              0.000051     let w:airline_lastmode = mode_string
   56              0.000019   endif
                            
   56              0.000039   return ''

FUNCTION  airline#util#append()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:49
Called 266 times
Total time:   0.002122
 Self time:   0.002122

count  total (s)   self (s)
  266              0.000442   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  266              0.000081   endif
  266              0.000609   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  266              0.000606   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  6()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:12
Called 6 times
Total time:   0.000089
 Self time:   0.000072

count  total (s)   self (s)
    6              0.000021   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    6   0.000065   0.000048   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  <SNR>48_sortByLength()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:467
Called 25 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
   25              0.000054   return len(a:i2[0])-len(a:i1[0])

FUNCTION  <SNR>115_cd_to_vcs_root()
    Defined: ~/.config/nvim/autoload/plugged/vim-startify/autoload/startify.vim:971
Called 1 time
Total time:   0.001362
 Self time:   0.001362

count  total (s)   self (s)
    1              0.000010   let dir = fnamemodify(a:path, ':p:h')
    5              0.000007   for vcs in [ '.git', '.hg', '.bzr', '.svn' ]
    4              0.001301     let root = finddir(vcs, dir .';')
    4              0.000009     if !empty(root)
                                  execute s:cd_cmd() fnameescape(fnamemodify(root, ':h'))
                                  return 1
    4              0.000002     endif
    5              0.000003   endfor
    1              0.000001   return 0

FUNCTION  <SNR>130_on_exit_clean()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:87
Called 1 time
Total time:   0.000104
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000005   let buf=self.buf
    1   0.000062   0.000012   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
    1              0.000004   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
    1              0.000018     call remove(s:clean_jobs[self.vcs], self.file)
    1              0.000000   endif

FUNCTION  <SNR>130_valid_dir()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:50
Called 10 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   10              0.000104   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
   10              0.000005   endif
   10              0.000009   return a:dir

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/branch.vim:183
Called 33 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
   33              0.000142   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
   33              0.000126   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
   33              0.000013   endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/themes.vim:31
Called 432 times
Total time:   0.072044
 Self time:   0.005481

count  total (s)   self (s)
  432   0.071849   0.005287   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>129_get_base_cmd()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:501
Called 1 time
Total time:   0.000103
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000002   let cmd = a:vcs_cmds[a:vcs]
    1   0.000063   0.000012   let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:bufnr, a:vcs))
    1   0.000012   0.000006   let cmd = s:replace(cmd, '%d', s:difftool)
    1   0.000024   0.000018   let cmd = s:replace(cmd, '%n', s:devnull)
    1              0.000001   return cmd

FUNCTION  airline#util#has_custom_scm()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:172
Called 38 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
   38              0.000137   return !empty(get(g:, 'airline#extensions#branch#custom_head', ''))

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 76 times
Total time:   0.002571
 Self time:   0.002571

count  total (s)   self (s)
   76              0.002450   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
   76              0.000065     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  <SNR>129_callback_nvim_stdout()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:15
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000005   let self.stdoutbuf[-1] .= a:data[0]
    1              0.000004   call extend(self.stdoutbuf, a:data[1:])

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:51
Called 10 times
Total time:   0.050254
 Self time:   0.001255

count  total (s)   self (s)
   10              0.000014   try
   10   0.001712   0.000094     call <sid>map_keys()
                              catch
                                " no-op
   10              0.000007   endtry
   10              0.000025   let cur = bufnr('%')
   10              0.000024   if cur == s:current_bufnr && &columns == s:column_width
    6              0.000025     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    4              0.000022       return s:current_tabline
    2              0.000001     endif
    6              0.000002   endif
                            
    6   0.000822   0.000100   let b = airline#extensions#tabline#new_builder()
    6              0.000022   let tab_bufs = tabpagebuflist(tabpagenr())
    6              0.000007   let show_buf_label_first = 0
                            
    6              0.000013   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
    6              0.000003   endif
    6              0.000005   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
    6              0.000002   endif
                            
    6              0.000025   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    6              0.000008   let b.overflow_group = 'airline_tabhid'
    6   0.000530   0.000077   let b.buffers = airline#extensions#tabline#buflist#list()
    6              0.000011   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
    6              0.000002   endif
                            
    6              0.000010   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    6              0.000016   if has("tablineat")
    6              0.000006     function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
    6              0.000005     function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
    6              0.000003   endif
                            
    6              0.000004   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    6              0.000027   let current_buffer = max([index(b.buffers, cur), 0])
    6              0.000013   let last_buffer = len(b.buffers) - 1
    6   0.000117   0.000032   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    6   0.000045   0.000024   call b.add_section('airline_tabfill', '')
    6   0.000033   0.000016   call b.split()
    6   0.000034   0.000019   call b.add_section('airline_tabfill', '')
    6              0.000006   if !show_buf_label_first
    6   0.000215   0.000057     call airline#extensions#tabline#add_label(b, 'buffers', 1)
    6              0.000002   endif
                            
    6   0.000120   0.000040   call airline#extensions#tabline#add_tab_label(b)
                            
    6              0.000012   let s:current_bufnr = cur
    6              0.000009   let s:column_width = &columns
    6   0.045874   0.000043   let s:current_tabline = b.build()
    6              0.000030   let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
    6              0.000007   return s:current_tabline

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:143
Called 81 times
Total time:   0.000497
 Self time:   0.000497

count  total (s)   self (s)
   81              0.000173   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
   81              0.000027   endif
   81              0.000063   return s:has_fugitive

FUNCTION  startify#open_buffers()
    Defined: ~/.config/nvim/autoload/plugged/vim-startify/autoload/startify.vim:402
Called 1 time
Total time:   0.133456
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000006   if exists('a:1')  " used in mappings
                                let entry = b:startify.entries[a:1]
                                if !empty(s:batchmode) && entry.type == 'file'
                                  call startify#set_mark(s:batchmode, a:1)
                                else
                                  call s:open_buffer(entry)
                                endif
                                return
    1              0.000000   endif
                            
    1              0.000027   let marked = filter(copy(b:startify.entries), 'v:val.marked')
    1              0.000002   if empty(marked)  " open current entry
    1   0.133403   0.000018     call s:open_buffer(b:startify.entries[line('.')])
    1              0.000002     return
                              endif
                            
                              enew
                              setlocal nobuflisted
                            
                              " Open all marked entries.
                              for entry in sort(values(marked), 's:sort_by_tick')
                                call s:open_buffer(entry)
                              endfor
                            
                              wincmd =
                            
                              if exists('#User#StartifyAllBuffersOpened')
                                doautocmd <nomodeline> User StartifyAllBuffersOpened
                              endif

FUNCTION  <SNR>129_initialize_job()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:448
Called 1 time
Total time:   0.000165
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000165   0.000025   return s:wrap_cmd(a:bufnr, a:vcs, s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds))

FUNCTION  airline#parts#filetype()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:102
Called 39 times
Total time:   0.000674
 Self time:   0.000389

count  total (s)   self (s)
   39   0.000654   0.000369   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 6 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    6              0.000032   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    6              0.000002   endif

FUNCTION  <SNR>33_LoadIndent()
    Defined: /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/indent.vim:13
Called 2 times
Total time:   0.006635
 Self time:   0.002442

count  total (s)   self (s)
    2              0.000008     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    2              0.000001     endif
    2              0.000007     let s = expand("<amatch>")
    2              0.000003     if s != ""
    2              0.000003       if exists("b:did_indent")
                            	unlet b:did_indent
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000012       for name in split(s, '\.')
    2   0.006577   0.002384 	exe 'runtime! indent/' . name . '.vim'
    4              0.000005       endfor
    2              0.000001     endif

FUNCTION  <SNR>108_map_keys()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:195
Called 10 times
Total time:   0.001618
 Self time:   0.001618

count  total (s)   self (s)
   10              0.000036   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   10              0.000009   if bidx_mode > 0
   10              0.000007     if bidx_mode == 1
  110              0.000115       for i in range(1, 10)
  100              0.001077         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i%10, i-1)
  110              0.000053       endfor
                                else
                                  let start_idx = bidx_mode == 2 ? 11 : 1
                                  for i in range(start_idx, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%02d :call <SID>select_tab(%d)<CR>', i, i-start_idx)
                                  endfor
   10              0.000005     endif
   10              0.000098     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   10              0.000075     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
   10              0.000004   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 6 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    6              0.000021   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    6              0.000002   endif

FUNCTION  sy#verbose()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy.vim:113
Called 6 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    6              0.000010   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
    6              0.000002   endif

FUNCTION  <SNR>97_group_not_done()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:26
Called 255 times
Total time:   0.001582
 Self time:   0.001582

count  total (s)   self (s)
  255              0.000604   if index(a:list, a:name) == -1
  243              0.000587     call add(a:list, a:name)
  243              0.000163     return 1
   12              0.000004   else
   12              0.000010     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
   12              0.000005     endif
   12              0.000006     return 0
                              endif

FUNCTION  <SNR>121_evaluate_tabline()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:209
Called 30 times
Total time:   0.002858
 Self time:   0.001274

count  total (s)   self (s)
   30              0.000037   let tabline = a:tabline
   30   0.001910   0.000327   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
   30              0.000240   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
   30              0.000157   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
   30              0.000108   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
   30              0.000088   let tabline = substitute(tabline, '%=', '', 'g')
   30              0.000087   let tabline = substitute(tabline, '%\d*\*', '', 'g')
   30              0.000054   if has('tablineat')
   30              0.000093     let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
   30              0.000013   endif
   30              0.000021   return tabline

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:35
Called 20 times
Total time:   0.000517
 Self time:   0.000412

count  total (s)   self (s)
   20              0.000054   if exists('s:current_buffer_list')
   17              0.000018     return s:current_buffer_list
    3              0.000001   endif
                            
    3              0.000008   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    3              0.000006   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    3              0.000007   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    3              0.000015   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    3              0.000003   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
   13              0.000011   for nr in list
   10              0.000013     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
    3              0.000005       if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
    3              0.000007       elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
    3   0.000102   0.000023       elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
    3   0.000047   0.000021       elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
    3              0.000001       endif
                            
    3              0.000006       call add(buffers, nr)
   10              0.000004     endif
   13              0.000013   endfor
                            
    3              0.000006   let s:current_buffer_list = buffers
    3              0.000002   return buffers

FUNCTION  airline#mode_changed()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline.vim:279
Called 14 times
Total time:   0.000405
 Self time:   0.000305

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
   14              0.000139   let g:airline#visual_active = (mode() =~? '[vs]')
   14   0.000225   0.000125   call airline#update_tabline()

FUNCTION  14()
    Defined: /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/autoload/provider/clipboard.vim:147
Called 1 time
Total time:   0.068531
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000004   if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
    1              0.000005   elseif s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
    1              0.000000   end
    1   0.068517   0.000022   return s:try_cmd(s:paste[a:reg])

FUNCTION  16()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:18
Called 6 times
Total time:   0.000085
 Self time:   0.000072

count  total (s)   self (s)
    6              0.000010   let self._first_title = a:first " lowest index
    6              0.000007   let self._last_title = a:last " highest index
    6              0.000006   let self._left_title = a:current " next index to add on the left
    6              0.000007   let self._right_title = a:current + 1 " next index to add on the right
    6   0.000041   0.000028   let self._left_position = self.get_position() " left end of titles
    6              0.000008   let self._right_position = self._left_position " right end of the titles

FUNCTION  17()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:41
Called 6 times
Total time:   0.003116
 Self time:   0.000348

count  total (s)   self (s)
    6   0.000587   0.000028   let title = self.get_title(a:index)
    6   0.002149   0.000058   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    6              0.000008   if a:force || self._remaining_space >= title_size
    6              0.000006     let pos = a:pos
    6              0.000011     if has_key(self, "get_pretitle")
    6   0.000114   0.000049       call self.insert_raw(self.get_pretitle(a:index), pos)
    6              0.000008       let self._right_position += 1
    6              0.000005       let pos += 1
    6              0.000002     endif
                            
    6   0.000051   0.000027     call self.insert_section(a:group, title, pos)
    6              0.000006     let self._right_position += 1
    6              0.000004     let pos += 1
                            
    6              0.000010     if has_key(self, "get_posttitle")
    6   0.000108   0.000081       call self.insert_raw(self.get_posttitle(a:index), pos)
    6              0.000007       let self._right_position += 1
    6              0.000004       let pos += 1
    6              0.000003     endif
                            
    6              0.000007     let self._remaining_space -= title_size
    6              0.000003     return 1
                              endif
                              return 0

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:214
Called 99 times
Total time:   0.066371
 Self time:   0.001837

count  total (s)   self (s)
   99              0.000577   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   99   0.065745   0.001211   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/po.vim:54
Called 6 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    6              0.000014   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    6              0.000002   endif

FUNCTION  <SNR>49_on_window_changed()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/plugin/airline.vim:51
Called 12 times
Total time:   0.095447
 Self time:   0.000614

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
   12              0.000037   if &buftype is# 'popup'
                                return
   12              0.000008   endif
                            
   12              0.000046   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
   12              0.000004   endif
   12              0.000050   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   12              0.000106   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   12              0.000122   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    6              0.000004     return
    6              0.000003   endif
    6              0.000027   let g:airline_last_window_changed = l:key
    6   0.000086   0.000059   call s:init()
    6   0.094852   0.000047   call airline#update_statusline()

FUNCTION  sy#set_buflocal_autocmds()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy.vim:126
Called 1 time
Total time:   0.000334
 Self time:   0.000334

count  total (s)   self (s)
    1              0.000002   augroup signify
    1              0.000278     execute printf('autocmd! * <buffer=%d>', a:bufnr)
                            
    1              0.000006     execute printf('autocmd BufEnter     <buffer=%d> call sy#start()', a:bufnr)
    1              0.000005     execute printf('autocmd WinEnter     <buffer=%d> call sy#start()', a:bufnr)
    1              0.000004     execute printf('autocmd BufWritePost <buffer=%d> call sy#start()', a:bufnr)
                            
    1              0.000004     execute printf('autocmd CursorHold   <buffer=%d> call sy#start()', a:bufnr)
    1              0.000004     execute printf('autocmd CursorHoldI  <buffer=%d> call sy#start()', a:bufnr)
                            
    1              0.000004     execute printf('autocmd FocusGained  <buffer=%d> SignifyRefresh', a:bufnr)
                            
    1              0.000004     execute printf('autocmd CmdwinEnter <buffer=%d> let g:signify_cmdwin_active = 1', a:bufnr)
    1              0.000004     execute printf('autocmd CmdwinLeave <buffer=%d> let g:signify_cmdwin_active = 0', a:bufnr)
                            
    1              0.000004     execute printf('autocmd ShellCmdPost <buffer=%d> call sy#start()', a:bufnr)
                            
    1              0.000002     if exists('##VimResume')
    1              0.000004       execute printf('autocmd VimResume <buffer=%d> call sy#start()', a:bufnr)
    1              0.000000     endif
    1              0.000001   augroup END
                            
    1              0.000002   if exists('#User#SignifyAutocmds')
                                doautocmd <nomodeline> User SignifyAutocmds
    1              0.000000   endif

FUNCTION  airline#util#winwidth()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:19
Called 377 times
Total time:   0.002784
 Self time:   0.002784

count  total (s)   self (s)
  377              0.000830   let nr = get(a:000, 0, 0)
  377              0.000649   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  377              0.000176   else
  377              0.000508     return winwidth(nr)
                              endif

FUNCTION  airline#util#doautocmd()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:176
Called 15 times
Total time:   0.001853
 Self time:   0.000970

count  total (s)   self (s)
   15   0.001842   0.000960   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>102_check_mixed_indent_file()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:34
Called 4 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    4              0.000019   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    4              0.000013   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    4              0.000002   else
    4              0.000004     let head_spc = '\v(^ +)'
    4              0.000001   endif
    4              0.000021   let indent_tabs = search('\v(^\t+)', 'nw')
    4              0.000034   let indent_spc  = search(head_spc, 'nw')
    4              0.000005   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    4              0.000002   else
    4              0.000002     return ''
                              endif

FUNCTION  <SNR>97_get_syn()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:38
Called 4244 times
Total time:   0.084754
 Self time:   0.084754

count  total (s)   self (s)
 4244              0.003670   let color = ''
 4244              0.011843   if hlexists(a:group)
 4012              0.018905     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 4244              0.001828   endif
 4244              0.006763   if empty(color) || color == -1
                                " should always exist
 1179              0.010213     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                " however, just in case
 1179              0.002032     if empty(color) || color == -1
  484              0.000425       let color = 'NONE'
 1179              0.000481     endif
 4244              0.001263   endif
 4244              0.002859   return color

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:38
Called 38 times
Total time:   0.001990
 Self time:   0.000403

count  total (s)   self (s)
   38   0.001968   0.000381   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline.vim:208
Called 14 times
Total time:   0.003097
 Self time:   0.000694

count  total (s)   self (s)
   14   0.000257   0.000193   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   14              0.000055   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   14   0.002773   0.000434   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>112_get_transitioned_seperator()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:140
Called 99 times
Total time:   0.069459
 Self time:   0.003088

count  total (s)   self (s)
   99              0.000105   let line = ''
   99              0.000355   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   99              0.000043   else
   99   0.067338   0.000968     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   99              0.000410     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   99              0.000289     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   99              0.000215     let line .= '%#'.a:group.'#'
   99              0.000036   endif
   99              0.000075   return line

FUNCTION  <SNR>99_update_branch()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/branch.vim:173
Called 38 times
Total time:   0.008263
 Self time:   0.002058

count  total (s)   self (s)
  114              0.000265   for vcs in keys(s:vcs_config)
   76   0.007200   0.000995     call {s:vcs_config[vcs].update_branch}()
   76              0.000214     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
   76              0.000033     endif
  114              0.000081   endfor

FUNCTION  airline#extensions#tabline#new_builder()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline.vim:214
Called 6 times
Total time:   0.000721
 Self time:   0.000284

count  total (s)   self (s)
    6              0.000077   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    6              0.000011   if get(g:, 'airline_powerline_fonts', 0)
    6              0.000024     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
    6              0.000021     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    6              0.000002   endif
                            
    6   0.000539   0.000101   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  10()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:29
Called 12 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   12              0.000037   call insert(self._sections, ['', a:text], a:position)

FUNCTION  11()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:33
Called 6 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    6              0.000010   return len(self._sections)

FUNCTION  12()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:62
Called 27 times
Total time:   0.116235
 Self time:   0.014078

count  total (s)   self (s)
   27              0.000024   let side = 1
   27              0.000021   let line = ''
   27              0.000018   let i = 0
   27              0.000046   let length = len(self._sections)
   27              0.000021   let split = 0
   27              0.000023   let is_empty = 0
   27              0.000025   let prev_group = ''
                            
  192              0.000192   while i < length
  165              0.000251     let section = self._sections[i]
  165              0.000202     let group = section[0]
  165              0.000239     let contents = section[1]
  165              0.000181     let pgroup = prev_group
  165   0.003062   0.001492     let prev_group = airline#builder#get_prev_group(self._sections, i)
  165              0.000333     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
  165              0.000461     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
  165              0.000370     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
  165              0.000090     endif
  165              0.000109     if is_empty
                                  let prev_group = pgroup
  165              0.000054     endif
  165   0.002653   0.001427     let is_empty = s:section_is_empty(self, contents)
                            
  165              0.000114     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
  165              0.000070     endif
                            
  165              0.000180     if group == ''
   12              0.000020       let line .= contents
  153              0.000149     elseif group == '|'
   27              0.000039       let side = 0
   27              0.000054       let line .= contents
   27              0.000016       let split = 1
  126              0.000051     else
  126              0.000113       if prev_group == ''
   27              0.000069         let line .= '%#'.group.'#'
   99              0.000058       elseif split
   27              0.000016         if !is_empty
   27   0.020939   0.000280           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   27              0.000013         endif
   27              0.000022         let split = 0
   72              0.000042       else
   72              0.000045         if !is_empty
   72   0.074525   0.000689           let line .= s:get_seperator(self, prev_group, group, side)
   72              0.000037         endif
  126              0.000053       endif
  126   0.006352   0.001487       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  165              0.000083     endif
                            
  165              0.000160     let i = i + 1
  192              0.000240   endwhile
                            
   27              0.000027   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    9              0.000404     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   27              0.000011   endif
   27              0.000022   return line

FUNCTION  <SNR>102_check_mixed_indent()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:17
Called 4 times
Total time:   0.000551
 Self time:   0.000551

count  total (s)   self (s)
    4              0.000012   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    4              0.000004   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    4              0.000004   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
    4              0.000002   else
    4              0.000501     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  18()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:96
Called 6 times
Total time:   0.045831
 Self time:   0.001262

count  total (s)   self (s)
    6              0.000017   if has_key(self, '_left_position') && self._first_title <= self._last_title
    6   0.014886   0.000076     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    6              0.000017     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    6   0.000388   0.000067     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    6   0.000272   0.000040     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    6   0.000109   0.000055     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    6   0.000133   0.000042     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    6              0.000021     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    6   0.000305   0.000054     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    6              0.000007     if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    6              0.000002     endif
    6              0.000006     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
    6              0.000002     endif
                            
                                " Add the current title
    6   0.000236   0.000027     let group = self.get_group(self._left_title)
    6              0.000006     if self._left_title == self._first_title
    6   0.000298   0.000102       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
                                else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    6              0.000002     endif
    6              0.000006     if self._left_title == self._last_title
    6   0.002205   0.000043       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
                                else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    6              0.000002     endif
    6              0.000006     let left_group = group
    6              0.000007     let right_group = group
    6   0.003156   0.000040     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    6              0.000012     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
    6              0.000002     endif
                            
    6              0.000015     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
    6              0.000002     endif
                            
    6              0.000009     while self._remaining_space > 0
    6              0.000006       let done = 0
    6              0.000006       if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
    6              0.000002       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    6              0.000009       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
    6              0.000002       endif
    6              0.000004       if !done
    6              0.000003         break
                                  endif
    6              0.000019     endwhile
                            
    6              0.000006     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
    6              0.000002     endif
                            
    6              0.000005     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
    6              0.000002     endif
    6              0.000002   endif
                            
    6   0.023160   0.000033   return self._build()

FUNCTION  <SNR>130_nvim_untracked_job_handler()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:238
Called 1 time
Total time:   0.000073
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000003     if a:event == 'exit'
    1   0.000062   0.000011       call s:untracked_output(self, self.buf)
    1              0.000003       if has_key(s:untracked_jobs, self.file)
    1              0.000003         call remove(s:untracked_jobs, self.file)
    1              0.000000       endif
    1              0.000000     endif

FUNCTION  <SNR>115_set_cursor()
    Defined: ~/.config/nvim/autoload/plugged/vim-startify/autoload/startify.vim:817
Called 6 times
Total time:   0.000284
 Self time:   0.000284

count  total (s)   self (s)
    6              0.000027   let b:startify.oldline = exists('b:startify.newline') ? b:startify.newline : s:fixed_column
    6              0.000010   let b:startify.newline = line('.')
                            
                              " going up (-1) or down (1)
    6              0.000015   if b:startify.oldline == b:startify.newline && col('.') != s:fixed_column && !b:startify.leftmouse
                                let movement = 2 * (col('.') > s:fixed_column) - 1
                                let b:startify.newline += movement
    6              0.000003   else
    6              0.000012     let movement = 2 * (b:startify.newline > b:startify.oldline) - 1
    6              0.000006     let b:startify.leftmouse = 0
    6              0.000003   endif
                            
                              " skip section headers lines until an entry is found
    6              0.000039   while index(b:startify.section_header_lines, b:startify.newline) != -1
                                let b:startify.newline += movement
    6              0.000020   endwhile
                            
                              " skip blank lines between lists
    6              0.000012   if empty(getline(b:startify.newline))
                                let b:startify.newline += movement
    6              0.000002   endif
                            
                              " don't go beyond first or last entry
    6              0.000053   let b:startify.newline = max([b:startify.firstline, min([b:startify.lastline, b:startify.newline])])
                            
    6              0.000014   call cursor(b:startify.newline, s:fixed_column)

FUNCTION  airline#extensions#tabline#add_label()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline.vim:252
Called 6 times
Total time:   0.000158
 Self time:   0.000069

count  total (s)   self (s)
    6              0.000013   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    6   0.000137   0.000048     call a:dict.add_section_spaced('airline_tablabel'. (a:right ? '_right' : ''), get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    6              0.000003   endif

FUNCTION  sy#util#shell_redirect()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/util.vim:77
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                              " if shellredir contains a %s it is replaced with the path
                              " otherwise, just append it (from :help shellredir:
                              "   The name of the temporary file can be represented by '%s' if necessary
                              "   (the file name is appended automatically if no %s appears in the value
                              "   of this option)
    1              0.000008   if &shellredir =~# '%s'
    1              0.000007     return substitute(&shellredir, '\C%s', a:path, 'g')
                              else
                                return &shellredir .' '. a:path
                              endif

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 15 times
Total time:   0.009190
 Self time:   0.000840

count  total (s)   self (s)
   15              0.000023   let winnr = a:context.winnr
   15              0.000017   let active = a:context.active
                            
   15   0.000181   0.000136   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    6   0.001605   0.000043     call s:build_sections(a:builder, a:context, s:layout[0])
    9              0.000005   else
    9   0.000426   0.000066     let text = s:get_section(winnr, 'c')
    9              0.000012     if empty(text)
                                  let text = ' %f%m '
    9              0.000004     endif
    9   0.000102   0.000054     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   15              0.000006   endif
                            
   15   0.000701   0.000145   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   15   0.000111   0.000077   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   15   0.005873   0.000128     call s:build_sections(a:builder, a:context, s:layout[1])
   15              0.000006   endif
                            
   15              0.000008   return 1

FUNCTION  <SNR>113_build_sections()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 21 times
Total time:   0.007307
 Self time:   0.001208

count  total (s)   self (s)
  114              0.000112   for key in a:keys
   93              0.000184     if (key == 'warning' || key == 'error') && !a:context.active
   18              0.000009       continue
   75              0.000025     endif
   75   0.006733   0.000635     call s:add_section(a:builder, a:context, key)
   96              0.000074   endfor

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:185
Called 21 times
Total time:   0.000813
 Self time:   0.000584

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
   21   0.000783   0.000554   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  <SNR>112_get_seperator()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:155
Called 72 times
Total time:   0.073836
 Self time:   0.001536

count  total (s)   self (s)
   72   0.024211   0.000711   if airline#builder#should_change_group(a:prev_group, a:group)
   72   0.049585   0.000785     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:195
Called 38 times
Total time:   0.000260
 Self time:   0.000260

count  total (s)   self (s)
   38              0.000134   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
   38              0.000015   endif

FUNCTION  <SNR>102_conflict_marker()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:52
Called 4 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
                              " Checks for git conflict markers
    4              0.000005   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    4              0.000009   if &ft is# 'rst'
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
    4              0.000001   else
    4              0.000014     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    4              0.000001   endif
    4              0.000163   return search(pattern, 'nw')

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:15
Called 39 times
Total time:   0.003475
 Self time:   0.003320

count  total (s)   self (s)
   39              0.000103   if !exists('b:fugitive_name')
    1              0.000001     let b:fugitive_name = ''
    1              0.000001     try
    1              0.000009       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    1              0.000002       elseif exists('b:git_dir') && exists('*fugitive#repo')
                                    if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
    1              0.000002       elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    1              0.000000       endif
                                catch
    1              0.000001     endtry
   39              0.000014   endif
                            
   39   0.000495   0.000340   let fmod = s:ModifierFlags()
   39              0.000072   if empty(b:fugitive_name)
   39              0.001891     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  <SNR>121_get_separator_change_with_end()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:76
Called 12 times
Total time:   0.002221
 Self time:   0.000251

count  total (s)   self (s)
   12              0.000014   let sep_change = 0
   12              0.000034   if !empty(a:new_end_group) " Separator between title and the end
    6   0.002035   0.000065     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
   12              0.000005   endif
   12              0.000016   if !empty(a:old_group) " Separator between the title and the one adjacent
                                let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
                                if !empty(a:old_end_group) " Remove mis-predicted separator
                                  let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
                                endif
   12              0.000003   endif
   12              0.000009   return sep_change

FUNCTION  airline#util#wrap()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:42
Called 362 times
Total time:   0.002433
 Self time:   0.001966

count  total (s)   self (s)
  362   0.001560   0.001093   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  362              0.000142   endif
  362              0.000297   return a:text

FUNCTION  <SNR>129_replace()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:529
Called 3 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    3              0.000025   let parts = split(a:cmd, a:pat, 1)
    3              0.000008   return join(parts, a:sub)

FUNCTION  FugitiveGitDir()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:11
Called 38 times
Total time:   0.001067
 Self time:   0.001067

count  total (s)   self (s)
   38              0.000100   if !a:0 || type(a:1) == type(0) && a:1 < 0
   38              0.000063     if exists('g:fugitive_event')
                                  return g:fugitive_event
   38              0.000016     endif
   38              0.000082     let dir = get(b:, 'git_dir', '')
   38              0.000558     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   38              0.000015     endif
   38              0.000028     return dir
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  sy#start()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy.vim:7
Called 3 times
Total time:   0.030526
 Self time:   0.000827

count  total (s)   self (s)
    3              0.000004   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
    3              0.000001   endif
                            
    3              0.000013   let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
    3              0.000008   let sy = getbufvar(bufnr, 'sy')
                            
    3              0.000004   if empty(sy)
    1   0.000058   0.000008     let path = s:get_path(bufnr)
    1   0.000064   0.000007     if s:skip(bufnr, path)
                                  call sy#verbose('Skip file: '. path)
                                  return
    1              0.000000     endif
    1   0.000050   0.000037     call sy#verbose('Register new file: '. path)
    1   0.000787   0.000261     let new_sy = { 'path':       path, 'buffer':     bufnr, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(path, ':p:h'),    'path': sy#util#escape(path),    'file': sy#util#escape(fnamemodify(path, ':t')) }}
    1              0.000004     call setbufvar(bufnr, 'sy', new_sy)
    1   0.000340   0.000006     call sy#set_buflocal_autocmds(bufnr)
    1   0.026551   0.000201     call sy#repo#detect(bufnr)
    2              0.000006   elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
    2              0.000001   else
    2   0.000203   0.000035     let path = s:get_path(bufnr)
    2              0.000041     if !filereadable(path)
                                  call sy#stop()
                                  return
    2              0.000004     elseif empty(sy.vcs)
    2              0.000003       if get(sy, 'retry')
                                    let sy.retry = 0
                                    call sy#verbose('Redetecting VCS.')
                                    call sy#repo#detect(sy.buffer)
    2              0.000001       else
    2              0.000003         if get(sy, 'detecting')
    1   0.000019   0.000006           call sy#verbose('Detection is already in progress.')
    1              0.000000         else
    1   0.000031   0.000019           call sy#verbose('No VCS found. Disabling.')
    1   0.002181   0.000005           call sy#stop(sy.buffer)
    2              0.000001         endif
    2              0.000001       endif
                                else
                                  for vcs in sy.vcs
                                    let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
                                    if type(job_id) != type(0) || job_id > 0
                                      call sy#verbose('Update is already in progress.', vcs)
                                    else
                                      call sy#verbose('Updating signs.', vcs)
                                      call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
                                    endif
                                  endfor
    2              0.000001     endif
    3              0.000001   endif

FUNCTION  <SNR>49_on_cursor_moved()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/plugin/airline.vim:83
Called 21 times
Total time:   0.000808
 Self time:   0.000609

count  total (s)   self (s)
   21              0.000229   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
   21              0.000021   endif
   21   0.000454   0.000256   call airline#update_tabline()

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline.vim:149
Called 10 times
Total time:   0.050881
 Self time:   0.000627

count  total (s)   self (s)
   10              0.000055   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   10              0.000023   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   10              0.000020   let curtabcnt = tabpagenr('$')
   10              0.000015   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                                call airline#extensions#tabline#tabws#invalidate()
   10              0.000005   endif
                            
   10              0.000030   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline(0)
   10              0.000003   endif
   10              0.000020   if !exists('#airline#SessionLoadPost')
                                autocmd airline SessionLoadPost * call <sid>update_tabline(1)
   10              0.000003   endif
   10              0.000024   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
   10              0.000007   elseif s:tabws
                                return airline#extensions#tabline#tabws#get()
   10              0.000014   elseif show_buffers && curtabcnt == 1 || !show_tabs
   10   0.050475   0.000221     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  airline#async#nvim_vcs_untracked()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:336
Called 5 times
Total time:   0.002291
 Self time:   0.002200

count  total (s)   self (s)
    5              0.000039   let cmd = a:cfg.cmd . shellescape(a:file)
    5              0.000005   let id = -1
    5   0.000255   0.000163   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
    5              0.000011   if has("nvim")
    5              0.000079     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
    5              0.000013     if has_key(s:untracked_jobs, config.file)
                                  " still running
    4              0.000003       return
    1              0.000000     endif
    1              0.000001     try
    1              0.001846     let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
    1              0.000001     endtry
    1              0.000005     let s:untracked_jobs[a:file] = id
    1              0.000002   endif
                              " vim without job feature or nvim jobstart failed
    1              0.000001   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
    1              0.000000   endif

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/term.vim:26
Called 9 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
    9              0.000040   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    9              0.000003   endif

FUNCTION  9()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:25
Called 6 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    6              0.000022   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:37
Called 171 times
Total time:   0.001625
 Self time:   0.001625

count  total (s)   self (s)
  171              0.000221   let x = a:i - 1
  210              0.000205   while x >= 0
  171              0.000257     let group = a:sections[x][0]
  171              0.000262     if group != '' && group != '|'
  132              0.000118       return group
   39              0.000016     endif
   39              0.000028     let x = x - 1
   78              0.000066   endwhile
   39              0.000026   return ''

FUNCTION  <SNR>129_handle_diff()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:116
Called 1 time
Total time:   0.000106
 Self time:   0.000074

count  total (s)   self (s)
    1   0.000027   0.000007   call sy#verbose('s:handle_diff()', a:options.vcs)
                            
    1              0.000002   if has_key(a:options, 'tempfiles')
                                for f in a:options.tempfiles
                                  call delete(f)
                                endfor
    1              0.000000   endif
                            
    1              0.000003   let sy = getbufvar(a:options.bufnr, 'sy')
    1              0.000001   if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
    1              0.000002   elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
    1              0.000001   elseif empty(sy.vcs)
    1              0.000002     let sy.detecting -= 1
    1              0.000000   endif
                            
    1              0.000005   let fenc = getbufvar(a:options.bufnr, '&fenc')
    1              0.000004   let enc  = getbufvar(a:options.bufnr, '&enc')
    1              0.000002   if (fenc != enc) && has('iconv')
                                call map(a:options.stdoutbuf, printf('iconv(v:val, "%s", "%s")', fenc, enc))
    1              0.000000   endif
                            
    1   0.000013   0.000010   let [found_diff, diff] = s:check_diff_{a:options.difftool}(a:exitval, a:options.stdoutbuf)
    1              0.000001   if found_diff
                                if index(sy.vcs, a:options.vcs) == -1
                                  let sy.vcs += [a:options.vcs]
                                endif
                                call a:options.func(sy, a:options.vcs, diff)
    1              0.000000   else
    1   0.000014   0.000005     call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
    1              0.000000   endif
                            
    1              0.000004   call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)

FUNCTION  <SNR>97_CheckDefined()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:126
Called 473 times
Total time:   0.011386
 Self time:   0.011386

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  473              0.001400   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  473              0.000254   endif
  473              0.001384   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  473              0.000158   endif
                            
  672              0.001017   for val in a:colors
  645              0.001462     if !empty(val) && val !=# 'NONE'
  446              0.000387       return a:colors
  199              0.000088     endif
  226              0.000143   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
   27              0.000036   let fg = g:airline#highlighter#normal_fg_hi
   27              0.000250   let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
   27              0.000024   if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
   27              0.000011   endif
   27              0.000195   return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>90_is_excluded_window()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 15 times
Total time:   0.000660
 Self time:   0.000660

count  total (s)   self (s)
   15              0.000039   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
   15              0.000029   endfor
                            
   60              0.000069   for matchw in g:airline_exclude_filenames
   45              0.000264     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
   45              0.000014     endif
   60              0.000028   endfor
                            
   15              0.000017   if g:airline_exclude_preview && &previewwindow
                                return 1
   15              0.000005   endif
                            
   15              0.000009   return 0

FUNCTION  airline#util#getwinvar()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:82
Called 183 times
Total time:   0.000577
 Self time:   0.000577

count  total (s)   self (s)
  183              0.000485     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  FugitiveDetect()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:272
Called 1 time
Total time:   0.000889
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000003   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
    1              0.000000   endif
    1              0.000002   if !exists('b:git_dir')
    1   0.000874   0.000009     let dir = FugitiveExtractGitDir(a:path)
    1              0.000001     if dir !=# ''
                                  let b:git_dir = dir
    1              0.000000     endif
    1              0.000000   endif
    1              0.000002   if !exists('b:git_dir') || !exists('#User#Fugitive')
    1              0.000001     return ''
                              endif
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
                              endif
                              return ''

FUNCTION  <SNR>100_ModifierFlags()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:11
Called 39 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
   39              0.000138   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 38 times
Total time:   0.006077
 Self time:   0.004296

count  total (s)   self (s)
   38              0.000124   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   38              0.000179   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   38              0.000015   endif
   38              0.000389   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   38              0.000090   if !exists('b:airline_whitespace_check')
    4              0.000006     let b:airline_whitespace_check = ''
    4              0.000015     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    4              0.000003     let trailing = 0
    4              0.000003     let check = 'trailing'
    4              0.000026     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    4              0.000003       try
    4              0.000009         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    4              0.000342         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    4              0.000003       endtry
    4              0.000002     endif
                            
    4              0.000016     let mixed = 0
    4              0.000003     let check = 'indent'
    4              0.000024     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    4   0.000581   0.000030       let mixed = s:check_mixed_indent()
    4              0.000003     endif
                            
    4              0.000005     let mixed_file = ''
    4              0.000004     let check = 'mixed-indent-file'
    4              0.000024     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    4   0.000175   0.000053       let mixed_file = s:check_mixed_indent_file()
    4              0.000001     endif
                            
    4              0.000003     let long = 0
    4              0.000007     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    4              0.000002     endif
                            
    4              0.000004     let conflicts = 0
    4              0.000006     if index(checks, 'conflicts') > -1
    4   0.000231   0.000025       let conflicts = s:conflict_marker()
    4              0.000002     endif
                            
    4              0.000013     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
    4              0.000001     endif
   38              0.000028   endif
   38   0.001190   0.000289   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>116_ExcludeOther()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:28
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000021   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
    3              0.000003     return 1 | endif

FUNCTION  <SNR>130_nvim_output_handler()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:232
Called 4 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    4              0.000015     if a:event == 'stdout' || a:event == 'stderr'
    4              0.000035       let self.buf .=  join(a:data)
    4              0.000002     endif

FUNCTION  AutoPairsInit()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:471
Called 1 time
Total time:   0.001273
 Self time:   0.000921

count  total (s)   self (s)
    1              0.000002   let b:autopairs_loaded  = 1
    1              0.000002   if !exists('b:autopairs_enabled')
    1              0.000001     let b:autopairs_enabled = 1
    1              0.000000   end
                            
    1              0.000001   if !exists('b:AutoPairs')
    1   0.000078   0.000013     let b:AutoPairs = AutoPairsDefaultPairs()
    1              0.000000   end
                            
    1              0.000002   if !exists('b:AutoPairsMoveCharacter')
    1              0.000002     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    1              0.000000   end
                            
    1              0.000001   let b:autopairs_return_pos = 0
    1              0.000002   let b:autopairs_saved_pair = [0, 0]
    1              0.000001   let b:AutoPairsList = []
                            
                              " buffer level map pairs keys
                              " n - do not map the first charactor of closed pair to close key
                              " m - close key jumps through multi line
                              " s - close key jumps only in the same line
   11              0.000021   for [open, close] in items(b:AutoPairs)
   10              0.000013     let o = open[-1:-1]
   10              0.000010     let c = close[0]
   10              0.000017     let opt = {'mapclose': 1, 'multiline':1}
   10              0.000014     let opt['key'] = c
   10              0.000009     if o == c
    6              0.000007       let opt['multiline'] = 0
   10              0.000004     end
   10              0.000071     let m = matchlist(close, '\v(.*)//(.*)$')
   10              0.000014     if len(m) > 0 
                                  if m[2] =~ 'n'
                                    let opt['mapclose'] = 0
                                  end
                                  if m[2] =~ 'm'
                                    let opt['multiline'] = 1
                                  end
                                  if m[2] =~ 's'
                                    let opt['multiline'] = 0
                                  end
                                  let ks = matchlist(m[2], '\vk(.)')
                                  if len(ks) > 0
                                    let opt['key'] = ks[1]
                                    let c = opt['key']
                                  end
                                  let close = m[1]
   10              0.000003     end
   10   0.000259   0.000080     call AutoPairsMap(o)
   10              0.000017     if o != c && c != '' && opt['mapclose']
    3   0.000061   0.000013       call AutoPairsMap(c)
   10              0.000004     end
   10              0.000042     let b:AutoPairsList += [[open, close, opt]]
   11              0.000008   endfor
                            
                              " sort pairs by length, longer pair should have higher priority
    1   0.000155   0.000094   let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
                            
   11              0.000007   for item in b:AutoPairsList
   10              0.000012     let [open, close, opt] = item
   10              0.000010     if open == "'" && open == close
    1              0.000001       let item[0] = '\v(^|\W)\zs'''
   10              0.000003     end
   11              0.000004   endfor
                            
                            
    9              0.000018   for key in split(b:AutoPairsMoveCharacter, '\s*')
    8              0.000040     let escaped_key = substitute(key, "'", "''", 'g')
    8              0.000070     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
    9              0.000004   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    1              0.000001   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    1              0.000007     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsMapCh
    1              0.000006     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   endif
                            
    1              0.000001   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    1              0.000001     let do_abbrev = ""
    1              0.000002     if v:version == 703 && has("patch489") || v:version > 703
    1              0.000001       let do_abbrev = "<C-]>"
    1              0.000000     endif
    1              0.000008     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutFastWrap != ''
    1              0.000007     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutBackInsert != ''
    1              0.000007     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    1              0.000007     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    1              0.000008     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutJump != ''
    1              0.000022     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    1              0.000020     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    1              0.000000   end
                            
    1              0.000002   if &keymap != ''
                                let l:imsearch = &imsearch
                                let l:iminsert = &iminsert
                                let l:imdisable = &imdisable
                                execute 'setlocal keymap=' . &keymap
                                execute 'setlocal imsearch=' . l:imsearch
                                execute 'setlocal iminsert=' . l:iminsert
                                if l:imdisable
                                  execute 'setlocal imdisable'
                                else
                                  execute 'setlocal noimdisable'
                                end
    1              0.000000   end
                            

FUNCTION  <SNR>105_update_tabline()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline.vim:57
Called 1 time
Total time:   0.008752
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000003   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
    1              0.000001   endif
                              " loading a session file
                              " On SessionLoadPost, g:SessionLoad variable is still set :/
    1              0.000002   if !a:forceit && get(g:, 'SessionLoad', 0)
                                return
    1              0.000000   endif
    1              0.000023   let match = expand('<afile>')
    1              0.000002   if pumvisible()
                                return
    1              0.000002   elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
    1   0.000044   0.000014   elseif empty(match) || airline#util#ignore_buf(match) || isdirectory(match)
                                return
    1              0.000000   endif
    1   0.000085   0.000022   call airline#util#doautocmd('BufMRUChange')
    1   0.008583   0.000006   call airline#extensions#tabline#redraw()

FUNCTION  <SNR>115_cd_cmd()
    Defined: ~/.config/nvim/autoload/plugged/vim-startify/autoload/startify.vim:984
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000019   let g:startify_change_cmd = get(g:, 'startify_change_cmd', 'lcd')
    1              0.000022   if g:startify_change_cmd !~# '^[lt]\?cd$'
                                call s:warn('Invalid value for g:startify_change_cmd. Defaulting to :lcd')
                                let g:startify_change_cmd = 'lcd'
    1              0.000001   endif
    1              0.000001   return g:startify_change_cmd

FUNCTION  sy#repo#get_diff()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:72
Called 1 time
Total time:   0.003764
 Self time:   0.003586

count  total (s)   self (s)
    1   0.000017   0.000006   call sy#verbose('sy#repo#get_diff()', a:vcs)
                            
    1              0.000003   let job_id = getbufvar(a:bufnr, 'sy_job_id_'.a:vcs)
                            
    1              0.000002   if getbufvar(a:bufnr, '&modified')
                                let [cmd, options] = s:initialize_buffer_job(a:bufnr, a:vcs)
                                let options.difftool = 'diff'
    1              0.000000   else
    1   0.000186   0.000021     let [cmd, options] = s:initialize_job(a:bufnr, a:vcs)
    1              0.000002     let options.difftool = a:vcs
    1              0.000000   endif
                            
    1              0.000001   let options.func = a:func
                            
    1              0.000002   if has('nvim')
    1              0.000001     if job_id
                                  silent! call jobstop(job_id)
    1              0.000000     endif
    1              0.003497     let job_id = jobstart(cmd, extend(options, { 'cwd':       getbufvar(a:bufnr, 'sy').info.dir, 'on_stdout': function('s:callback_nvim_stdout'), 'on_exit':   function('s:callback_nvim_exit'), }))
    1              0.000013     call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              elseif has('patch-8.0.902')
                                if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
                                endif
                                let opts = { 'cwd':      getbufvar(a:bufnr, 'sy').info.dir, 'in_io':    'null', 'out_cb':   function('s:callback_vim_stdout', options), 'close_cb': function('s:callback_vim_close', options), }
                                let job_id = job_start(cmd, opts)
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
    1              0.000000   endif

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline.vim:156
Called 6 times
Total time:   0.037896
 Self time:   0.000547

count  total (s)   self (s)
    6   0.000194   0.000048   if airline#util#stl_disabled(winnr())
                                return
    6              0.000002   endif
   15              0.000031   for nr in a:range
    9   0.000507   0.000103     if airline#util#stl_disabled(nr)
                                  continue
    9              0.000004     endif
    9              0.000024     call setwinvar(nr, 'airline_active', 0)
    9              0.000037     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    9              0.000016     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
    9              0.000004     endif
    9   0.036925   0.000126     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   15              0.000019   endfor

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:42
Called 38 times
Total time:   0.001312
 Self time:   0.000328

count  total (s)   self (s)
   38   0.001284   0.000300   return airline#extensions#nvimlsp#get('Error')

FUNCTION  <SNR>49_init()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/plugin/airline.vim:15
Called 6 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    6              0.000013   if s:airline_initialized
    6              0.000004     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  airline#extensions#tabline#group_of_bufnr()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline.vim:232
Called 18 times
Total time:   0.000288
 Self time:   0.000288

count  total (s)   self (s)
   18              0.000030   let cur = bufnr('%')
   18              0.000015   if cur == a:bufnr
   12              0.000036     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    3              0.000003       let group = 'airline_tabmod'
    9              0.000004     else
    9              0.000008       let group = 'airline_tabsel'
   12              0.000004     endif
    6              0.000002   else
    6              0.000018     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
    6              0.000010     elseif index(a:tab_bufs, a:bufnr) > -1
    3              0.000003       let group = 'airline_tab'
    3              0.000001     else
    3              0.000003       let group = 'airline_tabhid'
    6              0.000002     endif
   18              0.000005   endif
   18              0.000012   return group

FUNCTION  airline#async#vcs_clean()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:95
Called 5 times
Total time:   0.001877
 Self time:   0.000181

count  total (s)   self (s)
    5              0.000006   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
    5              0.000012   elseif has("nvim")
                                " nvim async
    5   0.001790   0.000094     noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
    5              0.000002   endif

FUNCTION  <SNR>32_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/ftplugin.vim:14
Called 2 times
Total time:   0.031587
 Self time:   0.008237

count  total (s)   self (s)
    2              0.000012     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000001     endif
                            
    2              0.000010     let s = expand("<amatch>")
    2              0.000003     if s != ""
    2              0.000018       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000015       for name in split(s, '\.')
    2   0.031496   0.008146 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    4              0.000007       endfor
    2              0.000001     endif

FUNCTION  FugitiveHead()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:128
Called 38 times
Total time:   0.001416
 Self time:   0.000349

count  total (s)   self (s)
   38   0.001306   0.000239   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   38              0.000066   if empty(dir)
   38              0.000019     return ''
                              endif
                              return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:237
Called 14 times
Total time:   0.155877
 Self time:   0.019098

count  total (s)   self (s)
   14              0.000023   let bufnr = a:0 ? a:1 : ''
   14              0.000051   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   14              0.000129   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   14              0.000025   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   14              0.000017   let airline_grouplist = []
   14              0.000056   let buffers_in_tabpage = sort(tabpagebuflist())
   14              0.000025   if exists("*uniq")
   14              0.000028     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   14              0.000020   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   32              0.000043   for mode in reverse(mapped)
   18              0.000089     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   10              0.000026       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  173              0.000307       for kvp in items(dict)
  163              0.000191         let mode_colors = kvp[1]
  163              0.000186         let name = kvp[0]
  163              0.000380         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    1              0.000002           let name = 'airline_c'.bufnr
  163              0.000062         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  163              0.000853         if name =~# 'airline_c\d\+'
    1              0.000008           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
    1              0.000003           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
    1              0.000000           endif
  162              0.000699         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   78              0.000041           continue
   85              0.000030         endif
   85   0.001137   0.000632         if s:group_not_done(airline_grouplist, name.suffix)
   81   0.022623   0.000746           call airline#highlighter#exec(name.suffix, mode_colors)
   85              0.000038         endif
                            
   85              0.000151         if !has_key(p, 'accents') 
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
   85              0.000048         endif
                            
  255              0.000407         for accent in keys(s:accents)
  170              0.000384           if !has_key(p.accents, accent)
                                        continue
  170              0.000076           endif
  170              0.000548           let colors = copy(mode_colors)
  170              0.000302           if p.accents[accent][0] != ''
   85              0.000165             let colors[0] = p.accents[accent][0]
  170              0.000062           endif
  170              0.000267           if p.accents[accent][2] != ''
   85              0.000122             let colors[2] = p.accents[accent][2]
  170              0.000055           endif
  170              0.000209           if len(colors) >= 5
  170              0.000405             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  170              0.000075           endif
  170   0.002681   0.001603           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  162   0.041907   0.001809             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  170              0.000088           endif
  255              0.000181         endfor
   95              0.000038       endfor
                            
   10              0.000015       if empty(s:separators)
                                    " nothing to be done
                                    continue
   10              0.000004       endif
                                  " TODO: optimize this
  127              0.000244       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  117   0.074556   0.001334         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  127              0.000077       endfor
   18              0.000007     endif
   32              0.000094   endfor

FUNCTION  <SNR>121_get_separator_change()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:68
Called 12 times
Total time:   0.002358
 Self time:   0.000137

count  total (s)   self (s)
   12   0.002353   0.000132   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  airline#builder#get_next_group()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:49
Called 6 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    6              0.000006   let x = a:i + 1
    6              0.000009   let l = len(a:sections)
   12              0.000010   while x < l
   12              0.000017     let group = a:sections[x][0]
   12              0.000018     if group != '' && group != '|'
    6              0.000005       return group
    6              0.000003     endif
    6              0.000004     let x = x + 1
    6              0.000003   endwhile
                              return ''

FUNCTION  airline#parts#ffenc()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:108
Called 39 times
Total time:   0.000940
 Self time:   0.000940

count  total (s)   self (s)
   39              0.000112   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   39              0.000056   let bomb     = &bomb ? '[BOM]' : ''
   39              0.000107   let noeolf   = &eol ? '' : '[!EOL]'
   39              0.000231   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   39              0.000189   if expected is# &fenc.bomb.noeolf.ff
                                return ''
   39              0.000014   else
   39              0.000160     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:6
Called 14 times
Total time:   0.002048
 Self time:   0.001720

count  total (s)   self (s)
   14              0.000056   let fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
   14              0.000032   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   14              0.000011   let _ = ''
                            
   14              0.000028   let name = bufname(a:bufnr)
   14              0.000018   if empty(name)
                                let _ .= '[No Name]'
   14              0.000064   elseif name =~ 'term://'
                                " Neovim Terminal
                                let _ = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
   14              0.000008   else
   14              0.000028     if get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   14              0.001026       let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
   14              0.000006     endif
   14              0.000044     if a:bufnr != bufnr('%') && fnametruncate && strlen(_) > fnametruncate
                                  let _ = airline#util#strcharpart(_, 0, fnametruncate)
   14              0.000005     endif
   14              0.000005   endif
                            
   14   0.000523   0.000195   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  sy#util#escape()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/util.vim:6
Called 3 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    3              0.000009   if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
    3              0.000001   endif
                            
    3              0.000009   let path = shellescape(a:path)
                            
    3              0.000004   if exists('old_ssl')
                                let &shellslash = old_ssl
    3              0.000001   endif
                            
    3              0.000003   return path

FUNCTION  <SNR>99_update_untracked()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/branch.vim:192
Called 38 times
Total time:   0.011163
 Self time:   0.005511

count  total (s)   self (s)
   38              0.002165   let file = expand("%:p")
   38              0.000446   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   38              0.000016   endif
                            
   38              0.000050   let needs_update = 1
   38              0.000163   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  114              0.000228   for vcs in keys(s:vcs_config)
   76              0.000303     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
   76              0.000031     endif
   76              0.000180     if has_key(s:vcs_config[vcs].untracked, file)
   33              0.000032       let needs_update = 0
   33   0.000865   0.000434       call airline#extensions#branch#update_untracked_config(file, vcs)
   76              0.000031     endif
  114              0.000082   endfor
                            
   38              0.000030   if !needs_update
   33              0.000020     return
    5              0.000002   endif
                            
   15              0.000033   for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
   10   0.000105   0.000074     if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
   10   0.000109   0.000063     elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
    5              0.000003       continue
    5              0.000002     endif
    5              0.000008     let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
    5              0.000011     if index(vcs_checks, 'untracked') > -1
    5   0.003505   0.000238       call airline#async#vcs_untracked(config, file, vcs)
    5              0.000003     endif
                                " Check clean state of repo
    5              0.000013     if index(vcs_checks, 'dirty') > -1
    5   0.001936   0.000059       call airline#async#vcs_clean(config.dirty, file, vcs)
    5              0.000011     endif
   10              0.000032   endfor

FUNCTION  <SNR>97_GetHiCmd()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:158
Called 122 times
Total time:   0.009860
 Self time:   0.009860

count  total (s)   self (s)
                              " a:list needs to have 5 items!
  122              0.000118   let res = ''
  122              0.000112   let i = -1
  732              0.000477   while i < 4
  610              0.000440     let i += 1
  610              0.001143     let item = get(a:list, i, '')
  610              0.000583     if item is ''
  122              0.000087       continue
  488              0.000187     endif
  488              0.000280     if i == 0
  122              0.000256       let res .= ' guifg='.item
  366              0.000220     elseif i == 1
  118              0.000206       let res .= ' guibg='.item
  248              0.000116     elseif i == 2
  122              0.000241       let res .= ' ctermfg='.item
  126              0.000118     elseif i == 3
   91              0.000158       let res .= ' ctermbg='.item
   35              0.000018     elseif i == 4
   35              0.000143       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  488              0.000209     endif
  610              0.000490   endwhile
  122              0.000132   return res

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:136
Called 60 times
Total time:   0.001752
 Self time:   0.001752

count  total (s)   self (s)
   60              0.000429   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   60              0.001273   return match(a:name, pat) > -1

FUNCTION  AutoPairsMap()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:445
Called 13 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
                              " | is special key which separate map command from text
   13              0.000014   let key = a:key
   13              0.000013   if key == '|'
                                let key = '<BAR>'
   13              0.000005   end
   13              0.000048   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   13              0.000120   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  airline#update_tabline()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline.vim:273
Called 35 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
   35              0.000144   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   35              0.000017   endif

FUNCTION  <SNR>64_Tree()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:164
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000001   let dir = a:path
    1              0.000003   if dir =~# '/\.git$'
                                return len(dir) ==# 5 ? '/' : dir[0:-6]
    1              0.000001   elseif dir ==# ''
    1              0.000001     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  airline#parts#get()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:49
Called 76 times
Total time:   0.000353
 Self time:   0.000353

count  total (s)   self (s)
   76              0.000297   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:63
Called 38 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
   38              0.000084   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  AutoPairsDefaultPairs()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:20
Called 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000002   if exists('b:autopairs_defaultpairs')
                                return b:autopairs_defaultpairs
    1              0.000000   end
    1              0.000005   let r = copy(g:AutoPairs)
    1              0.000006   let allPairs = { 'vim': {'\v^\s*\zs"': ''}, 'rust': {'\w\zs<': '>', '&\zs''': ''}, 'php': {'<?': '?>//k]', '<?php': '?>//k]'} }
    4              0.000008   for [filetype, pairs] in items(allPairs)
    3              0.000004     if &filetype == filetype
    2              0.000004       for [open, close] in items(pairs)
    1              0.000002         let r[open] = close
    2              0.000016       endfor
    3              0.000001     end
    4              0.000002   endfor
    1              0.000002   let b:autopairs_defaultpairs = r
    1              0.000001   return r

FUNCTION  airline#update_statusline()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline.vim:127
Called 6 times
Total time:   0.094806
 Self time:   0.000447

count  total (s)   self (s)
    6   0.000304   0.000042   if airline#util#stl_disabled(winnr())
                                return
    6              0.000002   endif
    6              0.000049   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    6   0.037955   0.000059   call airline#update_statusline_inactive(range)
                            
    6              0.000012   unlet! w:airline_render_left w:airline_render_right
    6              0.000075   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    6              0.000009   let w:airline_active = 1
    6              0.000027   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    6   0.056336   0.000136   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>113_get_section()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 111 times
Total time:   0.004633
 Self time:   0.003759

count  total (s)   self (s)
  111              0.000218   if has_key(s:section_truncate_width, a:key)
   75   0.001076   0.000526     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
   75              0.000024     endif
  111              0.000033   endif
  111              0.000147   let spc = g:airline_symbols.space
  111              0.000365   if !exists('g:airline_section_{a:key}')
                                return ''
  111              0.000030   endif
  111   0.001329   0.001005   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  111              0.000624   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  111              0.000365   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#parts#readonly()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:89
Called 56 times
Total time:   0.002745
 Self time:   0.001102

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   56   0.002281   0.000639   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   56              0.000050   endif
   56              0.000117   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   56              0.000036   else
   56              0.000072     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  airline#extensions#tabline#redraw()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline.vim:79
Called 1 time
Total time:   0.008577
 Self time:   0.008577

count  total (s)   self (s)
                              " sometimes, the tabline is not correctly updated see #1580
                              " so force redraw here
    1              0.000002   if exists(":redrawtabline") == 2
    1              0.008570     redrawtabline
                              else
                              " Have to set a property equal to itself to get airline to re-eval.
                              " Setting `let &tabline=&tabline` destroys the cursor position so we
                              " need something less invasive.
                                let &ro = &ro
    1              0.000000   endif

FUNCTION  <SNR>112_get_accented_line()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:163
Called 126 times
Total time:   0.004865
 Self time:   0.004865

count  total (s)   self (s)
  126              0.000139   if a:self._context.active
                                " active window
   90              0.000107     let contents = []
   90              0.000509     let content_parts = split(a:contents, '__accent')
  186              0.000233     for cpart in content_parts
   96              0.000590       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   96              0.000197       call add(contents, cpart)
  186              0.000191     endfor
   90              0.000340     let line = join(contents, a:group)
   90              0.000484     let line = substitute(line, '__restore__', a:group, 'g')
   36              0.000015   else
                                " inactive window
   36              0.000397     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   36              0.000195     let line = substitute(line, '%#__restore__#', '', 'g')
  126              0.000049   endif
  126              0.000106   return line

FUNCTION  <SNR>69_dopopd()
    Defined: ~/.config/nvim/autoload/plugged/fzf/plugin/fzf.vim:541
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000007   if !exists('w:fzf_pushd')
    2              0.000001     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  airline#highlighter#exec()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:102
Called 473 times
Total time:   0.121754
 Self time:   0.027490

count  total (s)   self (s)
  473              0.000655   if pumvisible()
                                return
  473              0.000171   endif
  473              0.000563   let colors = a:colors
  473              0.000396   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  473              0.000172   endif
  473   0.074608   0.005082   let old_hi = airline#highlighter#get_highlight(a:group)
  473              0.000720   if len(colors) == 4
  217              0.000449     call add(colors, '')
  473              0.000178   endif
  473              0.002628   let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  473   0.014986   0.003601   let colors = s:CheckDefined(colors)
  473   0.006671   0.003178   if old_hi != new_hi || !s:hl_group_exists(a:group)
  122   0.011001   0.001141     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  122              0.001109     exe cmd
  122              0.000302     if has_key(s:hl_groups, a:group)
  122              0.000223       let s:hl_groups[a:group] = colors
  122              0.000052     endif
  473              0.000130   endif

FUNCTION  sy#buffer_is_active()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy.vim:108
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return !empty(getbufvar(bufnr(''), 'sy'))

FUNCTION  airline#extensions#tabline#buffers#invalidate()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:47
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   let s:current_bufnr = -1

FUNCTION  <SNR>99_init_buffer()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/branch.vim:51
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000002   let b:buffer_vcs_config = {}
    3              0.000005   for vcs in keys(s:vcs_config)
    2              0.000007     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',     'dirty': 0,   }
    3              0.000002   endfor
    1              0.000001   unlet! b:airline_head

FUNCTION  <SNR>112_section_is_empty()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:182
Called 165 times
Total time:   0.001226
 Self time:   0.001226

count  total (s)   self (s)
  165              0.000180   let start=1
                            
                              " do not check for inactive windows or the tabline
  165              0.000186   if a:self._context.active == 0
   45              0.000027     return 0
  120              0.000249   elseif get(a:self._context, 'tabline', 0)
   66              0.000035     return 0
   54              0.000018   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   54              0.000108   if get(g:, 'airline_skip_empty_sections', 0) == 0
   54              0.000027     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#async#vcs_untracked()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:57
Called 5 times
Total time:   0.002442
 Self time:   0.000151

count  total (s)   self (s)
    5              0.000007   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
    5              0.000003   else
                                " nvim async or vim without job-feature
    5   0.002385   0.000094     noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
    5              0.000003   endif

FUNCTION  <SNR>129_get_vcs_path()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:494
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000028   return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)') ? getbufvar(a:bufnr, 'sy').info.file : getbufvar(a:bufnr, 'sy').info.path

FUNCTION  <SNR>98_get_hunks_signify()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/hunks.vim:29
Called 38 times
Total time:   0.000631
 Self time:   0.000330

count  total (s)   self (s)
   38   0.000497   0.000196   let hunks = sy#repo#get_stats()
   38              0.000046   if hunks[0] >= 0
                                return hunks
   38              0.000013   endif
   38              0.000021   return []

FUNCTION  sy#repo#get_stats()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:232
Called 38 times
Total time:   0.000301
 Self time:   0.000301

count  total (s)   self (s)
   38              0.000143   let sy = getbufvar(a:0 ? a:1 : bufnr(''), 'sy')
   38              0.000133   return empty(sy) ? [-1, -1, -1] : sy.stats

FUNCTION  <SNR>130_set_clean_variables()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:67
Called 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000018   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
    1              0.000014   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
    1              0.000002     let var[a:vcs].dirty=a:val
    1              0.000001     try
    1              0.000009       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
    1              0.000002       unlet! b:airline_head
                                catch
    1              0.000001     endtry
    1              0.000000   endif

FUNCTION  <SNR>97_get_array()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:54
Called 1061 times
Total time:   0.005414
 Self time:   0.005414

count  total (s)   self (s)
 1061              0.005002   return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  airline#extensions#fzf#inactive_apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/fzf.vim:37
Called 9 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    9              0.000022   if getbufvar(a:2.bufnr, '&filetype') ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    9              0.000003   endif

FUNCTION  <SNR>130_untracked_output()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:12
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000029   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
    1              0.000013   else
    1              0.000003     let a:dict.cfg.untracked[a:dict.file] = ''
    1              0.000001   endif

FUNCTION  <SNR>117_try_cmd()
    Defined: /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/autoload/provider/clipboard.vim:37
Called 1 time
Total time:   0.068495
 Self time:   0.000700

count  total (s)   self (s)
    1   0.068474   0.000679   let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
    1              0.000004   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
    1              0.000000   endif
    1              0.000002   return out

FUNCTION  <SNR>129_callback_nvim_exit()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:21
Called 1 time
Total time:   0.000121
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000120   0.000013   return s:handle_diff(self, a:exitval)

FUNCTION  <SNR>99_update_hg_branch()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/branch.vim:138
Called 38 times
Total time:   0.002056
 Self time:   0.001784

count  total (s)   self (s)
   38   0.000572   0.000300   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   38              0.000016   else
   38              0.000073     let s:vcs_config['mercurial'].branch = ''
   38              0.000015   endif

FUNCTION  <SNR>121_tabline_evaluated_length()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:223
Called 30 times
Total time:   0.003341
 Self time:   0.000396

count  total (s)   self (s)
   30   0.003327   0.000381   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  <SNR>127_skip()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy.vim:164
Called 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000024   if getbufvar(a:bufnr, '&diff') || !filereadable(a:path)
                                return 1
    1              0.000000   endif
                            
    1              0.000002   if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, getbufvar(a:bufnr, '&filetype'))
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && getbufvar(a:bufnr, '&buftype') == 'help'
                                  return 1
                                endif
    1              0.000000   endif
                            
    1              0.000003   if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
    1              0.000000   endif
                            
                              " DEPRECATED: Use g:signify_skip.pattern instead.
    1              0.000002   if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
    1              0.000000   endif
                            
    1              0.000001   if exists('g:signify_skip')
                                if has_key(g:signify_skip, 'pattern')
                                  for pattern in g:signify_skip.pattern
                                    if a:path =~ pattern
                                      return 1
                                    endif
                                  endfor
                                endif
    1              0.000000   endif
                            
    1              0.000001   return 0

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:155
Called 6 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    6              0.000036   let path = substitute(a:path, '[\/]$', '', '') . '/'
    6              0.000073   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  airline#parts#spell()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:67
Called 38 times
Total time:   0.000869
 Self time:   0.000869

count  total (s)   self (s)
   38              0.000448   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   38              0.000055   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   38              0.000012   endif
   38              0.000021   return ''

FUNCTION  <SNR>97_exec_separator()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:183
Called 216 times
Total time:   0.137756
 Self time:   0.009580

count  total (s)   self (s)
  216              0.000311   if pumvisible()
                                return
  216              0.000070   endif
  216              0.000658   let group = a:from.'_to_'.a:to.a:suffix
  216   0.038994   0.001875   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  216   0.036844   0.001920   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  216              0.000147   if a:inverse
   61              0.000217     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  155              0.000060   else
  155              0.000468     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  216              0.000081   endif
  216              0.000620   let a:dict[group] = colors
  216   0.058322   0.002190   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>115_check_user_options()
    Defined: ~/.config/nvim/autoload/plugged/vim-startify/autoload/startify.vim:942
Called 1 time
Total time:   0.001604
 Self time:   0.000196

count  total (s)   self (s)
    1              0.000003   let session = a:path . s:sep .'Session.vim'
                            
    1              0.000014   if get(g:, 'startify_session_autoload') && filereadable(glob(session))
                                execute 'silent bwipeout' a:path
                                call startify#session_delete_buffers()
                                execute 'source' session
                                return
    1              0.000000   endif
                            
    1   0.001372   0.000010   if get(g:, 'startify_change_to_vcs_root') && s:cd_to_vcs_root(a:path)
                                return
    1              0.000000   endif
                            
    1              0.000002   if get(g:, 'startify_change_to_dir', 1)
    1              0.000009     if isdirectory(a:path)
                                  execute s:cd_cmd() a:path
    1              0.000001     else
    1              0.000003       let dir = fnamemodify(a:path, ':h')
    1              0.000019       if isdirectory(dir)
    1   0.000148   0.000101         execute s:cd_cmd() dir
                                  else
                                    " Do nothing. E.g. a:path == `scp://foo/bar`
    1              0.000000       endif
    1              0.000000     endif
    1              0.000000   endif

FUNCTION  <SNR>45_register()
    Defined: ~/.config/nvim/autoload/plugged/vim-go/plugin/go.vim:274
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000015   if !(&modifiable && expand('<amatch>') ==# 'go')
    2              0.000003     return
                              endif
                            
                              call go#lsp#DidOpen(expand('<afile>:p'))

FUNCTION  <SNR>64_Slash()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:313
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003   if exists('+shellslash')
                                return tr(a:path, '\', '/')
    1              0.000001   else
    1              0.000001     return a:path
                              endif

FUNCTION  <SNR>82_LocalBrowse()
    Defined: /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 3 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    3              0.000007   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    3              0.000002   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    3              0.000023   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    3              0.000091   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    3              0.000001   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    3              0.000001   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  sy#sign#remove_all_signs()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/sign.vim:202
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000006   let sy = getbufvar(a:bufnr, 'sy', {})
                            
    1              0.000003   for hunk in get(sy, 'hunks', [])
                                for id in get(hunk, 'ids', [])
                                  execute 'sign unplace' id 'buffer='.a:bufnr
                                endfor
    1              0.000001   endfor
                            
    1              0.000002   let sy.hunks = []

FUNCTION  sy#stop()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy.vim:76
Called 1 time
Total time:   0.002176
 Self time:   0.000598

count  total (s)   self (s)
    1              0.000002   let bufnr = bufnr('')
    1              0.000004   if empty(getbufvar(a:0 ? a:1 : bufnr, 'sy')) | return | endif
    1   0.001884   0.000306   call sy#sign#remove_all_signs(bufnr)
    1              0.000280   execute printf('autocmd! signify * <buffer=%d>', bufnr)
    1              0.000004   call setbufvar(bufnr, 'sy', {})

FUNCTION  airline#parts#crypt()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:59
Called 38 times
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
   38              0.000217   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:33
Called 14 times
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
   14              0.000048   let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
   14              0.000033   let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
   14              0.000026   let buf_modified_symbol = g:airline_symbols.modified
                            
   14              0.000030   let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
   14              0.000073   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   14              0.000040   if getbufvar(a:bufnr, '&modified') == 1
    2              0.000003     let _ .= buf_modified_symbol
   14              0.000006   endif
   14              0.000010   return _

FUNCTION  <SNR>113_add_section()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 75 times
Total time:   0.006099
 Self time:   0.002063

count  total (s)   self (s)
   75              0.000244     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   75   0.000940   0.000331     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   75              0.000023     endif
   75              0.000042     if condition
                                  call a:builder.add_raw('%(')
   75              0.000025     endif
   75   0.004324   0.000897     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   75              0.000049     if condition
                                  call a:builder.add_raw('%)')
   75              0.000027     endif

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/branch.vim:239
Called 38 times
Total time:   0.024411
 Self time:   0.004484

count  total (s)   self (s)
   38              0.000109   if !exists('b:buffer_vcs_config')
    1   0.000027   0.000007     call s:init_buffer()
   38              0.000014   endif
                            
   38   0.008564   0.000301   call s:update_branch()
   38   0.011538   0.000375   call s:update_untracked()
                            
   38              0.000137   if exists('b:airline_head') && !empty(b:airline_head)
                                return b:airline_head
   38              0.000013   endif
                            
   38              0.000059   let b:airline_head = ''
   38              0.000125   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
   38              0.000033   let heads = []
  114              0.000114   for vcs in vcs_priority
   76              0.000168     if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
   76              0.000041     endif
  114              0.000059   endfor
                            
   38              0.000039   for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
   38              0.000074   endfor
                            
   38              0.000045   if empty(heads)
   38   0.000642   0.000314     if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
   38              0.000014     endif
   38              0.000013   endif
                            
   38              0.000041   if empty(heads)
   38   0.000404   0.000252     if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
   38              0.000012     endif
   38              0.000011   endif
                            
   38              0.000116   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
   38              0.000011   endif
                            
   38              0.000034   return b:airline_head

FUNCTION  airline#extensions#tabline#buflist#clean()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:10
Called 1 time
Total time:   0.000017
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000008   0.000007   call airline#extensions#tabline#buflist#invalidate()
    1   0.000008   0.000006   call airline#extensions#tabline#buffers#invalidate()

FUNCTION  airline#parts#mode()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:55
Called 38 times
Total time:   0.001427
 Self time:   0.000407

count  total (s)   self (s)
   38   0.001405   0.000384   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 38 times
Total time:   0.001711
 Self time:   0.001077

count  total (s)   self (s)
   38              0.000175   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1   0.000010   0.000006     if get(g:, 'loaded_signify') && sy#buffer_is_active()
    1              0.000001       let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
    1              0.000000     endif
   38              0.000026   endif
   38   0.001007   0.000376   return {b:source_func}()

FUNCTION  airline#extensions#tabline#buflist#invalidate()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:6
Called 8 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    8              0.000027   unlet! s:current_buffer_list

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 6 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    6              0.000025   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    6              0.000003   endif

FUNCTION  <SNR>130_set_clean_jobs_variable()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:80
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000007   if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
    1              0.000001   endif
    1              0.000005   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  <SNR>102_ws_refresh()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:185
Called 13 times
Total time:   0.000209
 Self time:   0.000209

count  total (s)   self (s)
   13              0.000123   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   10              0.000012     return
    3              0.000002   endif
    3              0.000014   unlet! b:airline_whitespace_check
    3              0.000006   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    3              0.000001   endif
    3              0.000022   let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#util#strchars()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:119
Called 30 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   30              0.000026   if s:has_strchars
   30              0.000046     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  <SNR>99_update_git_branch()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 38 times
Total time:   0.004149
 Self time:   0.002006

count  total (s)   self (s)
   38   0.000660   0.000399   call airline#util#ignore_next_focusgain()
   38   0.000511   0.000256   if !airline#util#has_fugitive() && !airline#util#has_gina()
                                let s:vcs_config['git'].branch = ''
                                return
   38              0.000010   endif
   38   0.000428   0.000216   if airline#util#has_fugitive()
   38   0.001805   0.000388     let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   38              0.000119     if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
   38              0.000013     endif
                              else
                                try
                                  let g:gina#component#repo#commit_length = s:sha1size
                                  let s:vcs_config['git'].branch = gina#component#repo#branch()
                                catch
                                endtry
                                if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
                                endif
   38              0.000012   endif

FUNCTION  <SNR>4_SynSet()
    Defined: /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/syntax/synload.vim:33
Called 2 times
Total time:   0.032454
 Self time:   0.004641

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000010   syn clear
    2              0.000005   if exists("b:current_syntax")
                                unlet b:current_syntax
    2              0.000001   endif
                            
    2              0.000005   let s = expand("<amatch>")
    2              0.000002   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    2              0.000002   elseif s == "OFF"
                                let s = ""
    2              0.000001   endif
                            
    2              0.000002   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000014     for name in split(s, '\.')
    2   0.032380   0.004567       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    4              0.000005     endfor
    2              0.000001   endif

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 6 times
Total time:   0.000260
 Self time:   0.000260

count  total (s)   self (s)
    6              0.000071   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    6              0.000010   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    6              0.000008   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
    2              0.000011     let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
    2              0.000024     if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
    2              0.000004     elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
    2              0.000016     endif
    6              0.000002   endif
                            
    6              0.000011   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    6              0.000002   endif

FUNCTION  <SNR>115_open_buffer()
    Defined: ~/.config/nvim/autoload/plugged/vim-startify/autoload/startify.vim:525
Called 1 time
Total time:   0.133385
 Self time:   0.001729

count  total (s)   self (s)
    1              0.000002   if a:entry.type == 'special'
                                execute a:entry.cmd
    1              0.000001   elseif a:entry.type == 'session'
                                execute a:entry.cmd a:entry.path
    1              0.000001   elseif a:entry.type == 'file'
    1              0.000003     if line2byte('$') == -1
                                  execute 'edit' a:entry.path
    1              0.000000     else
    1              0.000001       if a:entry.cmd == 'tabnew'
                                    wincmd =
    1              0.000000       endif
    1   0.131746   0.001694       execute a:entry.cmd a:entry.path
    1              0.000002     endif
    1   0.001616   0.000012     call s:check_user_options(a:entry.path)
    1              0.000000   endif
    1              0.000005   if exists('#User#StartifyBufferOpened')
                                doautocmd <nomodeline> User StartifyBufferOpened
    1              0.000000   endif

FUNCTION  <SNR>97_hl_group_exists()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:93
Called 351 times
Total time:   0.003493
 Self time:   0.003493

count  total (s)   self (s)
  351              0.001103   if !hlexists(a:group)
                                return 0
  351              0.001307   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  351              0.000153   endif
  351              0.000167   return 1

FUNCTION  airline#async#nvim_vcs_clean()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/async.vim:305
Called 5 times
Total time:   0.001696
 Self time:   0.001601

count  total (s)   self (s)
    5   0.000267   0.000205     let config = { 'buf': '', 'vcs': a:vcs, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')), 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), 'on_exit': function('s:on_exit_clean')}
    5              0.000008     if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
    5              0.000002     else
    5              0.000016       let cmd = [&shell, &shellcmdflag, a:cmd]
    5              0.000002     endif
                            
    5              0.000010     if !has_key(s:clean_jobs, a:vcs)
    1              0.000002       let s:clean_jobs[a:vcs] = {}
    5              0.000002     endif
    5              0.000012     if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
    4              0.000002       return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
    1              0.000000     endif
    1              0.001225     let id = jobstart(cmd, config)
    1   0.000124   0.000090     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  airline#extensions#tabline#builder#new()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:227
Called 6 times
Total time:   0.000438
 Self time:   0.000212

count  total (s)   self (s)
    6   0.000305   0.000080   let builder = airline#builder#new(a:context)
    6              0.000011   let builder._build = builder.build
    6              0.000093   call extend(builder, s:prototype, 'force')
    6              0.000021   return builder

FUNCTION  airline#statusline()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline.vim:190
Called 56 times
Total time:   0.000914
 Self time:   0.000914

count  total (s)   self (s)
   56              0.000421   if has_key(s:contexts, a:winnr)
   56              0.000400     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>129_check_diff_git()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:161
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  sy#repo#detect()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:6
Called 1 time
Total time:   0.003800
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000003   let sy = getbufvar(a:bufnr, 'sy')
    2              0.000003   for vcs in s:vcs_list
    1              0.000002     let sy.detecting += 1
    1   0.003782   0.000019     call sy#repo#get_diff(a:bufnr, vcs, function('sy#sign#set_signs'))
    2              0.000004   endfor

FUNCTION  airline#extensions#apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 15 times
Total time:   0.001602
 Self time:   0.000942

count  total (s)   self (s)
   15              0.000056   let filetype_overrides = get(s:, 'filetype_overrides', {})
   15              0.000090   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
   15   0.000915   0.000255   if s:is_excluded_window()
                                return -1
   15              0.000004   endif
                            
   15              0.000020   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
   15              0.000005   endif
                            
   15              0.000031   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
   15              0.000005   endif
                            
   15              0.000064   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
   15              0.000005   endif
                            
   15              0.000015   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
   15              0.000005   endif
                            
   15              0.000039   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
   15              0.000013   endfor

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:130
Called 78 times
Total time:   0.025471
 Self time:   0.002073

count  total (s)   self (s)
   78              0.000113   if a:group1 == a:group2
                                return 0
   78              0.000040   endif
   78   0.013138   0.000835   let color1 = airline#highlighter#get_highlight(a:group1)
   78   0.011805   0.000710   let color2 = airline#highlighter#get_highlight(a:group2)
   78              0.000251   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  polyglot#sleuth#GlobForFiletype()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/sleuth.vim:641
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000013   return get(s:globs, a:type, '')

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:158
Called 43 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
   43              0.000143   if !exists("s:has_lawrencium")
    1              0.000003     let s:has_lawrencium  = exists('*lawrencium#statusline')
   43              0.000031   endif
   43              0.000038   return s:has_lawrencium

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:62
Called 1061 times
Total time:   0.159486
 Self time:   0.069319

count  total (s)   self (s)
                              " only check for the cterm reverse attribute
                              " TODO: do we need to check all modes (gui, term, as well)?
 1061              0.006213   let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
 1061              0.003309   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
 1061              0.000496   else
 1061   0.030300   0.007912     let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
 1061   0.028390   0.007480     let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
 1061   0.028513   0.007255     let guifg = s:get_syn(a:group, 'fg', 'gui')
 1061   0.027366   0.007168     let guibg = s:get_syn(a:group, 'bg', 'gui')
 1061              0.004647     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 1061              0.000837     if reverse
                                  let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
 1061              0.000534     else
 1061   0.014350   0.008936       let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
 1061              0.000453     endif
 1061              0.000325   endif
 1061              0.003615   let s:hl_groups[a:group] = res
 1061              0.000737   return res

FUNCTION  provider#clipboard#Call()
    Defined: /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/autoload/provider/clipboard.vim:212
Called 1 time
Total time:   0.068599
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000025   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
    1              0.000001   endif
    1              0.000002   let s:here = v:true
    1              0.000001   try
    1   0.068561   0.000030     return call(s:clipboard[a:method],a:args,s:clipboard)
    1              0.000001   finally
    1              0.000002     let s:here = v:false
    1              0.000001   endtry

FUNCTION  airline#util#shorten()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:28
Called 114 times
Total time:   0.003021
 Self time:   0.002064

count  total (s)   self (s)
  114   0.002013   0.001056   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  114              0.000036   else
  114              0.000082     return a:text
                              endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/highlighter.vim:223
Called 14 times
Total time:   0.004362
 Self time:   0.000715

count  total (s)   self (s)
   14              0.000057   if getbufvar(a:bufnr, '&modified')
    1              0.000009     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   13              0.000006   else
   13              0.000173     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   14              0.000007   endif
                            
   14              0.000020   if !empty(colors)
   14   0.003994   0.000348     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   14              0.000005   endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/branch.vim:308
Called 38 times
Total time:   0.027328
 Self time:   0.001643

count  total (s)   self (s)
   38   0.024714   0.000303   let head = airline#extensions#branch#head()
   38   0.000587   0.000412   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   38              0.000117   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   38   0.001531   0.000432   let head = airline#util#shorten(head, winwidth, minwidth)
   38              0.000129   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   38              0.000200   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 38 times
Total time:   0.001252
 Self time:   0.001252

count  total (s)   self (s)
   38              0.000186   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   38              0.000136     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   38              0.000125     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   38              0.000219     let default = get(g:, 'airline#extensions#keymap#default', '')
   38              0.000043     if (label !=# '')
   38              0.000077       let label .= ' '
   38              0.000016     endif
   38              0.000043     let keymap = &keymap
   38              0.000071     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   38              0.000014     endif
   38              0.000186     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  <SNR>12_guess()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2781
Called 9 times
Total time:   0.012137
 Self time:   0.009783

count  total (s)   self (s)
    9              0.000022     let options = {}
    9              0.000010     let ccomment = 0
    9              0.000007     let podcomment = 0
    9              0.000007     let triplequote = 0
    9              0.000006     let backtick = 0
    9              0.000006     let xmlcomment = 0
    9              0.000008     let heredoc = ''
    9              0.000007     let minindent = 10
    9              0.000009     let spaces_minus_tabs = 0
    9              0.000006     let lineno = 0
    9              0.000010     let stack = [0]
    9              0.000028     let indents = { '2': 0, '3': 0, '4': 0, '6': 0, '8': 0 }
                            
  138              0.000132     for line in a:lines
  129              0.000104       let lineno += 1
                            
  129              0.000419       if line =~# '^\s*$'
   30              0.000015         continue
   99              0.000034       endif
                            
   99              0.000402       if line =~# '^\s*/\*'
                                    let ccomment = 1
   99              0.000033       endif
   99              0.000062       if ccomment
                                    if line =~# '\*/'
                                      let ccomment = 0
                                    endif
                                    continue
   99              0.000047       endif
                            
   99              0.000238       if line =~# '^=\w'
                                    let podcomment = 1
   99              0.000030       endif
   99              0.000060       if podcomment
                                    if line =~# '^=\%(end\|cut\)\>'
                                      let podcomment = 0
                                    endif
                                    continue
   99              0.000030       endif
                            
   99              0.000057       if triplequote
                                    if line =~# '^[^"]*"""[^"]*$'
                                      let triplequote = 0
                                    endif
                                    continue
   99              0.001009       elseif line =~# '^[^"]*"""[^"]*$'
                                    let triplequote = 1
   99              0.000034       endif
                            
   99              0.000057       if backtick
                                    if line =~# '^[^`]*`[^`]*$'
                                      let backtick = 0
                                    endif
                                    continue
   99              0.000178       elseif &filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                    let backtick = 1
   99              0.000031       endif
                            
   99              0.000390       if line =~# '^\s*<\!--'
                                    let xmlcomment = 1
   99              0.000031       endif
   99              0.000069       if xmlcomment
                                    if line =~# '-->'
                                      let xmlcomment = 0
                                    endif
                                    continue
   99              0.000029       endif
                            
                                  " This is correct order because both "<<EOF" and "EOF" matches end
   99              0.000107       if heredoc != ''
                                    if line =~# heredoc
                                      let heredoc = ''
                                    endif
                                    continue
   99              0.000030       endif
   99              0.000587       let herematch = matchlist(line, '\C<<\W*\([A-Z]\+\)\s*$')
   99              0.000161       if len(herematch) > 0
                                    let heredoc = herematch[1] . '$'
   99              0.000033       endif
                            
   99              0.000115       if line[0] == "\t"
                                    let spaces_minus_tabs -= 1
   99              0.000037       else
   99              0.000122         if line[0] == " "
   15              0.000030           let spaces_minus_tabs += 1
   99              0.000034         endif
   99              0.000476         let indent = len(matchstr(line, '^ *'))
  108              0.000103         while stack[-1] > indent
    9              0.000014           call remove(stack, -1)
  108              0.000052         endwhile
                            
   99              0.000119         let indent_inc = indent - stack[-1]
                            
   99              0.000167         if indent_inc == 0 && len(stack) > 1
    6              0.000006           let indent_inc = indent - stack[-2]
   99              0.000033         endif
                            
   99              0.000162         if has_key(indents, indent_inc)
   15              0.000019           let indents[indent_inc] += 1
   15              0.000026           let prev_indent = indent
   99              0.000046         endif
                            
   99              0.000095         if stack[-1] != indent
    9              0.000029           call add(stack, indent)
   99              0.000048         endif
   99              0.000031       endif
  108              0.000171     endfor
                            
    9              0.000010     if spaces_minus_tabs < 0
                                  setlocal noexpandtab
                                  let &l:shiftwidth=&tabstop
                                  return 1
    9              0.000003     endif
                            
    9   0.002482   0.000128     let shiftwidth = s:get_shiftwidth(indents)
                            
    9              0.000008     if shiftwidth > 0
    3              0.000029       setlocal expandtab
    3              0.000030       let &l:shiftwidth=shiftwidth
    3              0.000002       try
                                    " Sunchronize tabstop with shiftwidth
    3              0.000008         let &l:softtabstop = -1
                                  catch /^Vim\%((\a\+)\)\=:E487/
                                    " -1 was not supported before Vim 7.4
                                    let &l:softtabstop = a:num_spaces
    3              0.000002       endtry
    3              0.000002       return 1
    6              0.000002     endif
                            
    6              0.000003     return 0

FUNCTION  <SNR>81_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/HEAD-c12ea02_1/share/nvim/runtime/plugin/matchparen.vim:39
Called 39 times
Total time:   0.002835
 Self time:   0.002835

count  total (s)   self (s)
                              " Remove any previous match.
   39              0.000129   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   39              0.000020   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   39              0.000130   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   39              0.000012   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   39              0.000087   let c_lnum = line('.')
   39              0.000064   let c_col = col('.')
   39              0.000031   let before = 0
                            
   39              0.000079   let text = getline(c_lnum)
   39              0.000558   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   39              0.000063   if empty(matches)
                                let [c_before, c] = ['', '']
   39              0.000022   else
   39              0.000155     let [c_before, c] = matches[1:2]
   39              0.000016   endif
   39              0.000430   let plist = split(&matchpairs, '.\zs[:,]')
   39              0.000104   let i = index(plist, c)
   39              0.000030   if i < 0
                                " not found, in Insert mode try character before the cursor
   39              0.000148     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   16              0.000030       let before = strlen(c_before)
   16              0.000015       let c = c_before
   16              0.000025       let i = index(plist, c)
   39              0.000017     endif
   39              0.000023     if i < 0
                                  " not found, nothing to do
   39              0.000027       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 38 times
Total time:   0.006091
 Self time:   0.003590

count  total (s)   self (s)
   38              0.000077   if !get(w:, 'airline_active', 0)
                                return ''
   38              0.000040   endif
                              " Cache values, so that it isn't called too often
   38   0.000894   0.000627   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   38              0.000014   endif
   38   0.002112   0.000400   let hunks = airline#extensions#hunks#get_raw_hunks()
   38              0.000032   let string = ''
   38   0.000512   0.000334   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   38              0.000065   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
                                for i in [0, 1, 2]
                                  if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
   38              0.000014   endif
   38   0.000947   0.000862   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
   38              0.000014   endif
                            
   38              0.000062   let b:airline_hunks = string
   38              0.000087   let b:airline_changenr = b:changedtick
   38   0.000569   0.000311   let s:airline_winwidth = airline#util#winwidth()
   38              0.000028   return string

FUNCTION  <SNR>12_detect_indent()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2914
Called 3 times
Total time:   0.033153
 Self time:   0.002106

count  total (s)   self (s)
    3              0.000006     if &buftype ==# 'help'
                                  return
    3              0.000001     endif
                            
                                " Do not autodetect indent if language or user sets it
    3              0.000005     if &l:shiftwidth != s:default_shiftwidth
                                  return
    3              0.000001     endif
                            
    3              0.000197     let b:sleuth_culprit = expand("<afile>:p")
    3   0.002650   0.000053     if s:guess(getline(1, 128))
                                  return
    3              0.000001     endif
    3   0.003022   0.000041     if s:guess(getline(1, 1024))
                                  return
    3              0.000001     endif
    3   0.000047   0.000033     let pattern = polyglot#sleuth#GlobForFiletype(&filetype)
    3              0.000005     if len(pattern) == 0
                                  return
    3              0.000001     endif
    3              0.000007     let pattern = '{' . pattern . ',.git,.svn,.hg}'
    3              0.000094     let dir = expand('%:p:h')
    3              0.000004     let level = 3
    3              0.000031     while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && level > 0
                                  " Ignore files from homedir and root 
    3              0.000032       if dir == expand('~') || dir == '/'
                                    unlet b:sleuth_culprit
                                    return
    3              0.000001       endif
    3   0.019895   0.001000       for neighbor in glob(dir . '/' . pattern, 0, 1)[0:level]
    3              0.000019         let b:sleuth_culprit = neighbor
                                    " Do not consider directories above .git, .svn or .hg
    3              0.000017         if fnamemodify(neighbor, ":h:t")[0] == "."
                                      let level = 0
                                      continue
    3              0.000002         endif
    3              0.000143         if neighbor !=# expand('%:p') && filereadable(neighbor)
    3   0.006906   0.000347           if s:guess(readfile(neighbor, '', 32))
    3              0.000002             return
                                      endif
                                    endif
                                  endfor
                            
                                  let dir = fnamemodify(dir, ':h')
                                  let level -= 1
                                endwhile
                            
                                let b:sleuth_culprit = "default"

FUNCTION  airline#parts#iminsert()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/parts.vim:82
Called 38 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
   38              0.000072   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   38              0.000027   endif
   38              0.000020   return ''

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 6 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    6              0.000007   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    6              0.000002   endif

FUNCTION  AutoPairsTryInit()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:603
Called 3 times
Total time:   0.001410
 Self time:   0.000137

count  total (s)   self (s)
    3              0.000012   if exists('b:autopairs_loaded')
    2              0.000001     return
    1              0.000000   end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    1              0.000001   if g:AutoPairsMapCR
    1              0.000002     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    1              0.000017       let info = maparg('<CR>', 'i', 0, 1)
    1              0.000001       if empty(info)
    1              0.000001         let old_cr = '<CR>'
    1              0.000001         let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
    1              0.000000       endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
    1              0.000000     end
                            
    1              0.000007     if old_cr !~ 'AutoPairsReturn'
    1              0.000001       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
    1              0.000000       end
                                  " Always silent mapping
    1              0.000014       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    1              0.000001     end
    1              0.000000   endif
    1   0.001287   0.000014   call AutoPairsInit()

FUNCTION  <SNR>92_invoke_funcrefs()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline.vim:177
Called 15 times
Total time:   0.092999
 Self time:   0.000785

count  total (s)   self (s)
   15   0.000497   0.000084   let builder = airline#builder#new(a:context)
   15   0.013305   0.000249   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   15              0.000010   if err == 1
   15   0.078855   0.000111     let a:context.line = builder.build()
   15              0.000083     let s:contexts[a:context.winnr] = a:context
   15              0.000044     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
   15              0.000161     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
   15              0.000006   endif

FUNCTION  <SNR>12_get_shiftwidth()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2759
Called 9 times
Total time:   0.002354
 Self time:   0.002354

count  total (s)   self (s)
    9              0.000012     let shiftwidth = 0
    9              0.000009     let max_count = 0
    9              0.000011     let final_counts = {}
   54              0.000156     for [indent, indent_count] in items(a:indents)
   45              0.000074       let indent_count = indent_count * 1.5
  270              0.000578       for [indent2, indent2_count] in items(a:indents)
  225              0.000357         if indent2 > indent && indent2 % indent == 0
   45              0.000091           let indent_count = indent_count + indent2_count
  225              0.000118         endif
  270              0.000099       endfor
   45              0.000118       let final_counts[indent] = indent_count
   54              0.000030     endfor
   54              0.000108     for [indent, final_count] in items(final_counts)
   45              0.000038       if final_count > max_count
    3              0.000003         let shiftwidth = indent
    3              0.000003         let max_count = final_count
   45              0.000015       endif
   54              0.000022     endfor
    9              0.000010     return shiftwidth

FUNCTION  airline#util#prepend()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:63
Called 195 times
Total time:   0.001111
 Self time:   0.001111

count  total (s)   self (s)
  195              0.000391   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  195              0.000072   endif
  195              0.000435   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  airline#util#has_vcscommand()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:165
Called 38 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
   38              0.000097   if !exists("s:has_vcscommand")
    1              0.000019     let s:has_vcscommand = exists('*VCSCommandGetStatusLine')
   38              0.000016   endif
   38              0.000114   return get(g:, 'airline#extensions#branch#use_vcscommand', 0) && s:has_vcscommand

FUNCTION  airline#util#getbufvar()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/util.vim:71
Called 21 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
   21              0.000044     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>129_wrap_cmd()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy/repo.vim:469
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000003   if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell)' ? a:cmd : ['sh', '-c', a:cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', a:cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, a:cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, a:cmd, &shellxquote])
                                  endif
                                endif
    1              0.000000   else
    1              0.000002     let cmd = ['sh', '-c', a:cmd]
    1              0.000000   endif
    1              0.000006   let options = { 'stdoutbuf': [''], 'vcs': a:vcs, 'bufnr': a:bufnr, }
    1              0.000001   return [cmd, options]

FUNCTION  <SNR>127_get_path()
    Defined: ~/.config/nvim/autoload/plugged/vim-signify/autoload/sy.vim:155
Called 3 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
    3              0.000194   let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
    3              0.000010   if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
    3              0.000002   endif
    3              0.000003   return path

FUNCTION  airline#extensions#tabline#add_tab_label()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions/tabline.vim:260
Called 6 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    6              0.000015   let show_tab_count = get(g:, 'airline#extensions#tabline#show_tab_count', 1)
    6              0.000006   if show_tab_count == 2
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
    6              0.000013   elseif show_tab_count == 1 && tabpagenr('$') > 1
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
    6              0.000002   endif

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/extensions.vim:500
Called 38 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
   38              0.000053   return s:loaded_ext

FUNCTION  airline#builder#new()
    Defined: ~/.config/nvim/autoload/plugged/vim-airline/autoload/airline/builder.vim:229
Called 21 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
   21              0.000183   let builder = copy(s:prototype)
   21              0.000034   let builder._context = a:context
   21              0.000039   let builder._sections = []
                            
   21              0.000316   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   21              0.000018   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   56   0.168564   0.006534  airline#check_mode()
 1061   0.159486   0.069319  airline#highlighter#get_highlight()
   14   0.155877   0.019098  airline#highlighter#highlight()
  216   0.137756   0.009580  <SNR>97_exec_separator()
    1   0.133456   0.000071  startify#open_buffers()
    1   0.133385   0.001729  <SNR>115_open_buffer()
  473   0.121754   0.027490  airline#highlighter#exec()
   27   0.116235   0.014078  12()
   12   0.095447   0.000614  <SNR>49_on_window_changed()
    6   0.094806   0.000447  airline#update_statusline()
   15   0.092999   0.000785  <SNR>92_invoke_funcrefs()
 4244   0.084754             <SNR>97_get_syn()
   72   0.073836   0.001536  <SNR>112_get_seperator()
  432   0.072044   0.005481  airline#themes#get_highlight()
   99   0.069459   0.003088  <SNR>112_get_transitioned_seperator()
    1   0.068599   0.000068  provider#clipboard#Call()
    1   0.068531   0.000036  14()
    1   0.068495   0.000700  <SNR>117_try_cmd()
   99   0.066371   0.001837  airline#highlighter#add_separator()
   10   0.050881   0.000627  airline#extensions#tabline#get()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 4244              0.084754  <SNR>97_get_syn()
 1061   0.159486   0.069319  airline#highlighter#get_highlight()
  473   0.121754   0.027490  airline#highlighter#exec()
   14   0.155877   0.019098  airline#highlighter#highlight()
   27   0.116235   0.014078  12()
  473              0.011386  <SNR>97_CheckDefined()
  122              0.009860  <SNR>97_GetHiCmd()
    9   0.012137   0.009783  <SNR>12_guess()
  216   0.137756   0.009580  <SNR>97_exec_separator()
    1              0.008577  airline#extensions#tabline#redraw()
    2   0.031587   0.008237  <SNR>32_LoadFTPlugin()
   56   0.168564   0.006534  airline#check_mode()
   38   0.011163   0.005511  <SNR>99_update_untracked()
  432   0.072044   0.005481  airline#themes#get_highlight()
 1061              0.005414  <SNR>97_get_array()
  126              0.004865  <SNR>112_get_accented_line()
    2   0.032454   0.004641  <SNR>4_SynSet()
   38   0.024411   0.004484  airline#extensions#branch#head()
   38   0.006077   0.004296  airline#extensions#whitespace#check()
  111   0.004633   0.003759  <SNR>113_get_section()

